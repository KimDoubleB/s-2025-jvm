- 클래스 파일에 서술된 정보를 JVM이 이용하려면 로드하는 작업이 필요
- 타 언어와 달리 자바에서는 런타임 시점에 클래스 로딩, 링킹, 초기화가 수행됨

## 클래스 로딩 시점

- 타입의 생애 주기는 로딩 -> 검증 -> 준비 -> 해석 -> 초기화 -> 사용 -> 언로딩
  - 로딩, 검증, 준비, 초기화, 언로딩은 순서대로 진행되어야 함.
- 초기화 단계는 시작되어야 하는 상황은 아래와 같다.
  - `new`, `getstatic`, `putstatic`, `invokestatic` 을 만났을 때, 해당 타입이 아직 초기화가 안 되었다면 초기화
  - 리플렉션 메서드를 사용할 때 해당 타입이 초기화가 안 되어 있다면 초기화
  - 클래스 초기화 시 상위 클래스가 초기화 되어 있지 않을 시 상위 클래스 초기화
  - 가상 머신 로드 이후 main 메서드가 포함된 클래스 실행
  - `REF_getStatic`, `REF_putStatic`, `REF_invokeStatic`, `REF_newInvokeSpecial` 타입 메서드 핸들을 해석해 얻은 `MethodHandle` 인스턴스 호출 시, 해당 클래스가 초기화 되어 있지 않은 경우
  - 인터페이스의 디폴트 메서드를 정의했다면, 해당 인터페이스를 직간접적으로 구현한 클래스가 초기화될 때 인터페이스부터 초기화
- 이 시나리오들이 설명하는 동작을 타입에 대한 능동 참조라고 부름.
- 타입 초기화를 촉발하지 않는 케이스는 수동 참조라 부름
  - 정적 필드 참조시 직접 정의한 클래스만 초기화
  - 배열에서 클래스를 참조 시 클래스 초기화 안 됨
    - 이는 `anewarray` 라는 바이트코드로 초기화 되기 때문
  - 상수 참조 - 컴파일 과정에서 호출하는 클래스의 상수풀에 저장

## 클래스 로딩 처리 과정

### 로딩

- 과정은 다음과 같다.
  - 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져옴
  - 바이트 스트림을 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
  - 로딩 대상 클래스를 표현하는 `java.lang.Class` 객체를 힙 메모리에 생성 -> 메서드 영역에 저장된 타입 데이터 활용 용도

- 어디서 들고올지에 대해서는 명세에 명시되어 있지 않으므로, 상당히 자유롭게 들고올 수 있다.
- 로딩 단계는 JVM 내장 부트스트랩 클래스 로더를 사용하거나, 사용자 정의 클래스 로더를 사용할 수 있음
  - 다만 배열은 클래스 로더가 생성하지 않음. (원소 타입 자체는 클래스 로더를 통해 로드 됨)
- 메서드 영역에 저장되는 형태도 표준화 되어 있지 않음

### 검증

- 검증의 목적은 아래와 같다.
  - 클래스 파일의 바이트 스트림에 담긴 정보가 JVM 명세에서 규정한 모든 제약을 만족하는지 확인한다.
  - 이 정보를 코드로 변환해 실행했을 때 JVM 보안을 위협하지 않는지 확인한다.

- 검증의 과정은 다음과 같다.
  - 파일 형식 검증
  - 메타데이터 검증
  - 바이트코드 검증
  - 심벌 참조 검증

### 준비

- 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계
  - 인스턴스 변수는 제외하고, 클래스 변수만 할당한다. (주로 static 변수)
- 일반적인 경우는 0이지만, 상수는 `ConstantValue` 속성이 붙으며 준비 단계 시점에 값을 할당함.

### 해석

- 심벌 참조를 직접 참조로 대체
  - 심벌 참조: `CONSTANT_Class_info` 등, 클래스 파일에서 참조를 의미하는 심벌
  - 직접 참조: 상대적 위치 및 포인터 등을 가리키는 참조
- 동일하 심벌 참조에 대해서도 해석 요청이 여러 번 이루어질 수 있으므로, 보통 캐싱을 한다. (`invokedynamic` 명령어 제외)

### 초기화

- cinit 실행
- 반드시 부모부터 실행함
- 단 하나의 스레드에서만 실행되고, 나머지 스레드는 블로킹 됨

## 클래스 로더

- 해당 클래스를 정의하는 바이너리 바이트 스트림 가져오기를 수행하도록 하는 코드

### 부모 위임 모델

- 부트스트랩 클래스 로더: Hotspot 에서는 C++로 구현
- 이외 모든 클래스 로더: `java.lang.ClassLoader` 를 상속해서 자바로 구현함
- 초기 JVM은 은 대부분 시스템이 제공하는 세 클래스 로더를 통해 로드됨.
  - 부트스크랩 클래스 로더: `JAVA_HOME/lib` 디렉토리나  `-Xbootclasspath` 매개변수로 지정한경로에 위치함 파일들과 JKVM이 클래스 라이브러리로 인식하는 파일들을 로드
  - 확장 클래스 로더: 자바로 구현되어 있으며, 시스템 변수로 지정한 경로의 클래스 라이브러리를 로드
  - 애플리케이션 클래스 로더: 클래스패스상의 클래스 라이브러리 들을 로드하는 역할을 하며, 개발자가 직접 사용 가능
- 처음부터 로드 하려 시도하지 않고, 일단 위로 올림

 ### 부모 위임 모델에 대한 도전

- JNDI -> 부트스트랩 클래스가 로드하지만, 자원을 찾고 중앙 관리해야 하기에 외부 코드를 호출해야 함.
  - 결국, 스레드별 ContextClassLoader 도입
