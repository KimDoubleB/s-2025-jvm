### 1. Serial GC
Serial GC는 가장 단순한 형태로, 단일 스레드를 사용하여 모든 가비지 컬렉션 작업을 순차적으로 처리한다. CPU 코어가 하나뿐인 초창기 데스크톱 환경을 위해 설계되었으며, 현대적인 멀티코어 서버 환경에는 부적합하다.
Serial GC는 가장 단순한 형태로, 단일 스레드를 사용하여 모든 가비지 컬렉션 작업을 순차적으로 처리한다. GC가 실행되는 동안 애플리케이션의 모든 스레드가 멈추는 'Stop-The-World'(STW)가 발생한다.
-   **동작 방식**: Young 영역은 Mark-Copy, Old 영역은 Mark-Sweep-Compact 알고리즘을 사용한다.
-   **장점**: 구현이 간단하고 메모리 사용량이 적어 작은 힙 환경에서 효율적이다.
-   **단점**: 단일 스레드로 동작하므로 힙이 커질수록 'Stop-The-World' 시간이 무한정 길어져 서버 애플리케이션에는 치명적이다.

### 2. Parallel GC
'처리량 컬렉터(Throughput Collector)'라는 명칭으로 더 잘 알려져 있으며, 여러 개의 스레드를 사용하여 GC 작업을 병렬로 처리한다. 이를 통해 Serial GC보다 'Stop-The-World' 시간을 단축시켰으며. Java 8의 기본 GC이다.
-   **동작 방식**: Serial GC와 알고리즘은 동일하지만, 여러 GC 스레드가 동시에 작업을 수행하여 STW 시간을 줄인다.
-   **장점**: 여러 CPU 코어를 활용하여 GC 작업을 빠르게 완료하므로, GC 시간을 제외한 순수 애플리케이션 실행 시간이 늘어난다.
-   **단점**: 여전히 STW 기반이며, 힙이 클 경우 한 번의 GC 중단 시간이 수 초에 달할 수 있다.

### 3. CMS (Concurrent Mark Sweep) GC
CMS는 'Stop-The-World' 시간을 최소화하기 위해 대부분의 GC 작업을 애플리케이션 스레드와 **동시에(concurrently)** 수행하도록 설계된 최초의 컬렉터이다.

-   **동작 방식**: 총 4단계로 진행되며, 이 중 애플리케이션 중단이 필요한 단계는 매우 짧다.
	1. **최초 표시 (Initial Mark)**: (STW) GC 루트와 직접 연결된 객체들만 표시하기 때문에 아주 빠르게 끝난다.
	2. **동시 표시 (Concurrent Mark)**: GC 루트와 직접 연결된 객체들로부터 시작해 객체 그래프 전체를 탐색한다. 시간이 오래 걸리지만 사용자 스레드를 멈추지 않고, GC 스레드와 동시에 실행된다.
	3. **재표시 (Remark)**: (STW) '동시 표시' 단계에서 변경된 참조 관계를 다시 확인하고 수정한다.
	4. **동시 쓸기 (Concurrent Sweep)**: 애플리케이션과 동시에 실행되며, 앞의 세 가지 표시 단계에서 죽었다고 판단한 객체들을 쓸어 담는다.
전체 과정 중 가장 긴 동시 표시와 동시 쓸기 단계에서 사용자 스레드를 멈추지 않기 때문에 일반적으로 CMS는 '사용자  스레드와 동시에 수행된다'고 말할 수 있다.
-   **장점**: STW 시간이 매우 짧다.
-   **단점**:
    -   **메모리 단편화**: CMS의 토대는 마크-스윕 알고리즘 이기 때문에, 힙에 파편화가 발생하여 매우 긴 Full GC를 유발할 수 있다.
    -   **높은 CPU 사용량**: GC 스레드가 애플리케이션과 CPU 자원을 경쟁한다.

CMS는 JDK9 때 폐기 대상으로 지정된 후 JDK 14에서 완전히 제거되었다.

### 4. G1 GC
G1(Garbage-First) GC는 CMS의 단점을 극복하고 **예측 가능한 중단 시간**을 제공하기 위해 설계되었다. Java 9부터 기본 GC로 채택되었다.
- **리전(Region) 기반 힙 관리**: G1은 기존의 연속된 Young/Old 세대 구조를 버리고, 전체 힙을 여러 개의 동일한 크기(보통 1MB~32MB)를 가진 **리전(Region)** 으로 분할한다. 각 리전은 필요에 따라 Eden, Survivor, Old의 역할을 동적으로 부여받는다.
- **"Garbage-First" 원칙과 예측 가능한 중단 시간**: G1은 **"쓰레기가 가장 많은(Garbage-First)"** 리전을 우선적으로, 그리고 사용자가 설정한 목표 중단 시간(`-XX:MaxGCPauseMillis`) 내에 처리할 수 있을 만큼만 수집한다.
-  이를 위해 각 리전은 자신을 참조하는 외부 리전의 정보를 **RSet(Remembered Set)** 에 기록하여, 전체 힙 스캔 없이도 부분적인 GC를 가능하게 한다.

**동작 방식**: G1은 여러 단계의 사이클을 통해 점진적으로 메모리를 회수한다.
1.    **Young-Only Phase**: Minor GC가 반복적으로 발생하며 Young 영역을 정리한다.
2.    **Concurrent Marking Cycle**: 힙 점유율이 임계점에 도달하면 시작된다.
		-  **Initial Mark (최초 표시)**: (STW) GC Root가 참조하는 객체를 표시한다. 사용자 스레드를일시 정지해야 하지만 소요 시간이 매우 짧은 데다 마이너 GC가 실행되는 시간을 틈타 동시에 끝나므로 G1이 추가로 일으키는 일시 정지는 없다고 할 수 있다.
	   - **Concurrent Marking (동시 표시)**: (동시) GC 루트로부터 시작하여 객체들의 도달 가능성을 분석하고, 전체 힙의 객체 그래프를 재귀적으로 스캔하며 회수할 객체를 찾는다. 이 단계는 시간이 걸리지만 사용자 스레드와 동시에 수행된다. 다만 객체 그래프 스캔이 끝난 후에는 시작 단계 스냅숏과 비교하여 동시 실행 도중 참조가 변경된 객체들을 다시 스캔해야 한다.
	    - **Remark (재표시)**: (STW) 최종적으로 살아있는 객체를 확정합니다. 시작단계 이후 변경된 소수의 객체만 처리하면 되므로 매우 빠르게 끝난다.
	    - **Cleanup (복사 및 청소)**: (STW + 동시) 통계 데이터를 기초로 살아있는 객체가 가장 적은 리전을 식별하고, 목표한 일시 정지 시간에 부합하도록 회수 계획을 세운다. 회수할 리전들을 선별하고 선별된 리전들에서 살아남은 객체들을 빈 리전에 복사후 기존 리전을 비운다. 이 단계는 생존한 객체를 이동시켜야 하므로 사용자 스레드가 잠시 멈춰야 하지만 다수의 GC 스레드가 병렬로 처리한다.


### 5. ZGC
G1의 중단 시간조차 허용되지 않는 초저지연(Ultra-Low-Latency) 시스템을 위해, STW를 거의 없앤 혁신적인 GC들이 등장했다. 이들의 핵심은 비용이 가장 많이 드는 **압축(Compaction) 작업을 애플리케이션과 동시에 수행**한다는 점이다.

#### **ZGC (Z Garbage Collector)**
ZGC는 힙 크기에 상관없이 **1ms 미만의 STW**를 목표로 하는 초저지연 GC이다.
-   **핵심 기술: Colored Pointers와 Load Barriers**
    -   **Colored Pointers**: 64비트 객체 포인터의 일부 비트를 GC 메타데이터(Marked, Remapped 등)로 사용한다. 이를 통해 객체의 상태를 포인터만 보고도 알 수 있다.
    -   **Load Barriers**: 애플리케이션이 힙에서 객체 참조를 읽을 때마다 실행되는 코드로, 포인터의 '색상'을 확인한다. 만약 객체가 이동했다면, 새 주소를 알려주고 참조를 수정하는 **'자가 치유(Self-Healing)'** 역할을 한다.
-   **동시 압축(Concurrent Compaction) 과정** 이 두 기술 덕분에 ZGC는 애플리케이션을 멈추지 않고도 객체를 안전하게 다른 리전으로 옮기고 메모리를 압축할 수 있다.

**동작 방식**: ZGC는 대부분의 작업을 동시(Concurrent)에 수행한다.
	
1. **동시 표시 (Concurrent Mark)**: G1처럼 객체 그래프를 탐색하며 도달 가능성을 분석한다. 다만 ZGC의 표시는 객체가 아니라 포인터에서 이루어진다. 
2.	**동시 재배치 준비 (Concurrent Relocation Preparation)**: 청소해야 할 리전들을 선정하여 재배치 집합을 만든다. 재배치 집합과 G1의 회수 집합은 차이가 있는데, G1이 리전을 나눈 이유는 회수 효율 순서로 줄을 세워 점진적으로 회수하기 위해서지만 ZGC는 가비지 컬렉션 때마다 모든 리전을 스캔한다. 
3. **동시 재배치 (Concurrent Relocate)**: ZGC의 가장 혁신적인 부분으로, 살아있는 객체를 새로운 리전으로 이동시켜 메모리 단편화를 제거(압축)한다. 만약 사용자 스레드가 재배치 집합에 포함된 객체에 동시에 접근하려 들면 미리 설정해둔 메모리 장벽이 끼어들어, 즉시 해당 리전의 포워드 테이블에 기록된 정보를 보고 새로운 객체로 포워드시킨다. 그와 동시에 해당 참조의 값도 새로운 객체를 가리키도록 갱신한다. ZGC에서는 이 동작을 포인터의 **자가 치유** 라고 부른다.

4. **동시 재매핑 (Concurrent Remap)**: 객체 이동 후, 힙에 남아있는 이전 주소를 가리키는 참조들을 모두 새 주소로 수정해야 한다. ZGC의 동시 재매핑은 '자가 치유' 덕에 시급하게 처리하지 않아도 된다.
	-   **자가 치유 (Self-Healing)**: ZGC는 모든 참조를 한 번에 업데이트하는 별도의 긴 단계를 두지 않는다. 대신, 참조가 실제로 사용될 때마다 점진적으로 수정하는 방식을 사용한다.
	    1.  애플리케이션 스레드가 어떤 객체 참조를 읽으려고 시도한다.
	    2.  이때 참조를 읽는 코드에 포함된 **자동 검사 로직**이 포인터의 '색상'을 확인한다.
	    3.  만약 색상이 '재배치됨(Remapped)'을 의미한다면, 이는 객체가 이미 다른 곳으로 이동했다는 뜻이다.
	    4.  이 경우, 검사 로직은 객체의 새로운 주소를 찾은 뒤, 애플리케이션 스레드가 가지고 있던 **참조 변수 자체를 새 주소로 업데이트** 한다. 이것이 바로 '자가 치유'이다.
	    5.  마지막으로, 올바른 새 주소를 애플리케이션 스레드에 반환한다.
	-   이러한 '자가 치유' 메커니즘 덕분에, 모든 참조를 업데이트하는 부담이 전체 애플리케이션 스레드에 분산되며, 실제 접근이 일어날 때만 수정이 발생하므로 매우 효율적이다.

### 정리

| 컬렉터 이름 | 핵심 메커니즘 | STW 동작 | 주된 목표 | 압축 전략 | 주요 JVM 플래그 |
|--------------|----------------|------------|------------|--------------|----------------|
| **Serial GC** | 단일 스레드, 순차 처리 | 전체 GC 주기 | 단순성 및 작은 힙에서의 효율 | Mark-Sweep-Compact | `-XX:+UseSerialGC` |
| **Parallel GC** | 다중 스레드, 병렬 처리 | 전체 GC 주기 | 처리량(Throughput) 극대화 | Mark-Sweep-Compact | `-XX:+UseParallelGC` |
| **CMS GC** *(Deprecated)* | 애플리케이션과 동시 마킹/스윕 | 짧은 초기/재마킹 | 지연 시간(Latency) 최소화 | 기본적으로 미수행 (Compaction 없음) | `-XX:+UseConcMarkSweepGC` |
| **G1 GC** *(기본 GC)* | 리전(Region) 기반, 가비지 우선 수집 | 짧은 Evacuation 중단 | 처리량과 지연 시간의 균형 | Evacuation (복사) | `-XX:+UseG1GC` |
| **ZGC** | 리전 기반, 동시 마킹 및 재배치 (Colored Pointers) | 1ms 미만의 단기 중단 | 초저지연(High scalability & Low latency) | 동시 재배치 (Concurrent Compaction) | `-XX:+UseZGC` |
| **Shenandoah GC** | 리전 기반, 동시 마킹 및 재배치 (Brooks Pointers) | 10ms 미만의 초단기 중단 | 저지연(Low-pause) 중심 | 동시 재배치 (Concurrent Compaction) | `-XX:+UseShenandoahGC` |

