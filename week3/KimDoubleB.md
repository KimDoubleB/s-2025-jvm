책에서 나온/언급된 가비지 컬렉터들
- 시리얼
- 파뉴
- 패러렐 스캐빈저
- 시리얼 올드
- 패러렐 올드
- CMS
- G1
- Shenandoah
- ZGC
- Epsilon
- PGC
- C4
- OpenJ9 GC들 (gencon, balanced, …)

<br/>

## 클래식 가비지 컬렉터

![image.png](attachment:18539d0a-79b0-4735-a16b-b3618689b0bd:image.png)

- ‘최고’, ‘만능’인 컬렉터는 등장하지 않았음. 즉, 특정 시나리오에 가장 적합한 컬렉터를 선택할 수 있을 뿐.
- 가비지 컬렉터의 가장 중요한 지표 3가지 (처리량, 지연시간, 메모리 사용량)

<br/>

**시리얼 컬렉터 / 신세대**

- 마크-카피 알고리즘
- 단일 스레드로 동작 → 모든 사용자 스레드 일시 정지
- 무조건 안좋아? → 아님. 간단하고 효율적이라는 이점.
    - 가용 메모리가 적은 상황에서는 알고리즘 자체가 요구하는 메모리 사용량이 가장 적음.
    - 오버헤드가 없어, 자연스럽게 회수 효율을 최대로 끌어냄.
    - 단일 코어 프로세서 일 때, 별다른 옵션을 주지 않았다면 기본적으로 Serial Collector를 이용함
        
        > We made G1 the default collector for server environments in JDK 9 (JEP 248). At that time, testing showed that Serial had significant advantages in throughput and footprint in constrained environments with a single CPU and less than 1792 MB of physical memory. We therefore adjusted the JVM's GC selection algorithm to choose Serial in such environments. ([link](https://openjdk.org/jeps/523))
        > 

<br/>

**파뉴 컬렉터 / 신세대**

- 마크-카피 알고리즘
- 시리얼 컬렉터를 병렬화 한 버전 → 스레드 회수에 멀티 스레드를 이용
- CMS에 통합되어 CMS의 일부가 되었다고 봐도 무방.
- 단일 코어 프로세서에서는 Serial Collector보다 성능 안좋음.

<br/>

**패러렐 스캐빈저(PS) 컬렉터  / 신세대**

- 마크-카피 알고리즘, 병렬 회수
- 처리량 제어가 목적
    - 처리량: 사용자 코드 실행 시간 / 사용자 코드 실행 시간 + GC 실행 시간
    - 매개변수 활용
        - `-XX:MaxGCPauseMillis`: GC 정시시간의 최대값
        - `-XX:GCTimeRatio`: 처리량 직접 지정
        - `-XX:+UseAdaptiveSizePolicy`: 신세대 크기, 에덴/생존자 비율 등 세부 설정 매개변수를 성능 모니터링 정보를 수집해 최적의 정지 시간과 최대 처리량을 제공할 수 있도록 동적으로 조율

<br/>

**시리얼 올드 컬렉터 / 구세대**

- 마크-컴팩트 알고리즘
- 단일 스레드로 동작
- 일반적으로는 사용안한다고 봐야 함
- CMS 컬렉터에서 동시 모드 실패(Concurrent Mode Failure)가 발생할 때 fallback으로 사용

<br/>

**패러렐 올드 컬렉터 / 구세대**

- 마크-컴팩트 알고리즘, 병렬 회수
- PS 컬렉터의 구세대용 버전

<br/>

**CMS 컬렉터 / 구세대**

- Concurrent Mark Sweep Collector → 마크-스윕 알고리즘
- 목적: GC에 따른 일시 정지 시간을 최소로 줄이는 것
- 표시/쓸기 단계를 사용자 스레드와 동시에 수행
- 동작방식
    - (1) 최초 표시 / STW: GC 루트와 연결된 객체만 표기
    - (2) 동시 표시: 객체 그래프 전체 탐색, 사용자 스레드와 함께 실행
    - (3) 재표시 / STW: 사용자 스레드가 참조 관계 변경한 객체 재표시 (증분 업데이트)
    - (4) 동시 쓸기: 죽었다고 판단한 객체 쓸기
- 가장 긴 동시 표시와 동시 쓸기 단계에서 사용자 스레드를 멈추지 않음
    - 다른 컬렉터에 비해 정지 시간이 매우 짧다.
- 문제
    - (1) 프로세스 자원에 민감
        - 사용자 스레드와 함께 동작하면서 리소스를 공유하니 전체 처리량을 떨어뜨리는 것을 피할 수 없음. 프로세스 자원이 여유롭지 않으면 안됨.
    - (2) Concurrent Mode Failure
        - 마크-스윕 알고리즘 ⇒ Floating Garbage, 메모리 파편화 발생
        - 사이즈가 큰 객체 할당 요청이 왔을 때, Concurrent Mode Failure 발생
            - 시리얼 올드 셀렉터를 통해 Floating Garbage 제거
            - Full GC 발생
        - 이러한 이슈를 해결하기 위해 Full GC 때 조각 모음(Compact)하는 옵션도 제공하긴 함

<br/>

**G1 컬렉터**

- Garbage First Collector
- 목적: 정지 시간 예측 모델(pause prediction model)을 만들고, 정지 시간 목표에 맞게 통제하는 것
- 핵심 아이디어
    - (1) Partial Collection
    - (2) Region Memory Layout
- 힙 메모리 어느 곳이든 회수 대상(Collection set/Cset)에 포함될 수 있음
    - ‘어느 세대에 속하는가?’가 아닌 **‘어느 영역에 쓰레기가 가장 많나?’, ‘회수했을 때, 이득이 어디가 가장 큰가?’ ⇒ ‘회수 효과가 가장 큰 리전부터 회수’**
- G1이 해결해야 했던 문제
    - **(1) 독립된 리전 → 리전 간 참조 문제는 어떻게 할 것인가?**
        - 해시 테이블 구조의 기억집합을 리전마다 저장, 활용.
            - 키는 ‘다른 리전의 시작 주소’, 값은 ‘카드 테이블의 인덱스 번호의 집합’.
            - ‘내가 가리키는 대상’과 ‘나를 가리키는 대상’을 모두 기록하는 양방향 카드 테이블 구조
        - 저장 양이 많다보니 전통적인 컬렉터보다 힙 메모리를 최소 10~20% 더 사용
    - **(2) 동시표시 단계 동안 GC 스레드와 사용자 스레드 서로 간섭하지 않도록 보장을 어떻게?**
        - 시작 단계 스냅숏 알고리즘 (SATB).
        - 리전마다 TAMS라는 2개의 포인터를 설계. 리전의 공간 일부를 새로운 객체 할당하기 위한 공간으로 구성해 활용. → 해당 포인트 범위 외의 경우, 회수 대상에서 제외.
    - **(3) 정지 시간 예측 모델을 어떻게 구현할 것인가?**
        - 이론적 기초: 감소 평균(Decaying Average)
            - 최근 데이터에 더 큰 가중치를 부여하고, 오래된 데이터에는 점점 작아지는 가중치를 적용하는 평균 계산 방법
        - 각종 데이터 수집
            - 리전별 회수 시간, 리전별 기억 집합에서 더럽혀진 카드 개수 등
        - 수집 된 데이터를 이용해 통계 분석 → 감소 평균
            - ‘최근’의 평균적인 상태를 계산. 이 정보를 통해 **어느 리전을 회수해야 사용자가 기대하는 정지 시간 내 가장 큰 효과를 거둘지 예측**.
- 동작방식
    - (1) 최초 표시 / STW
        - GC 루트가 직접 참조하는 객체 표시, TAMS 포인터 값 수정
        - 시작 단계 스냅숏 생성
    - (2) 동시 표시
        - GC 루트로부터 객체들의 도달 가능성 분석, 객체 그래프 스캔
    - (3) 재표시 / STW
        - 시작 단계 스냅숏 이후 변경된 소수의 객체만 재확인
    - (4) 복사 및 청소 / STW
        - 통계 데이터를 기초로 목표한 일시 정지 시간에 부합하도록 회수 계획을 수립
        - 회수할 리전을 선별하고, 선별된 리전에서 살아남은 객체를 빈 리전에 이주, 그 후 리전 청소.
    - ⇒ `(2) 동시 표시` 말고는 다 STW 발생하는데? CMS보다 멈추는 경우가 더 많네?
        - G1 GC는 단순히 짧은 정지 시간만 추구하는게 아님.
        - **정지 시간을 제어하는 동시에 처리량을 최대한 높인다는 것**
- 정지 시간은 어떻게 정해야 할까?
    - 정지시간은 `현실적인 기댓값`이여야 함. 즉, 정지 시간을 낮추고 싶다고 무한정 낮춰서는 안됨.
    - 기본 값은 200 millis.
    - 만약 이걸 낮춰서 20 millis로 설정하면 어떨까?
        - 목표한 시간이 너무 짧아 힙 메모리의 아주 적은 일부만 회수하고 컬렉션을 마쳐야 함.
        - 회수 속도가 새로 할당되는 속도를 따라잡지 못하는 문제 발생.
        - 시간이 길어짐에 따라 힙이 가득 차고, Full GC가 발생해 성능 하락.
    - 객체가 버려지는 속도를 따라갈 수만 있다면 모든 것이 완벽하게 동작하는 모델.

---

<br/>

## 저지연 가비지 컬렉터

앞서 말한 중요한 지표 3가지
- 처리량
- 지연 시간
- 메모리 사용량

<br/>

**요즘에 와서는 ‘지연 시간’의 중요성이 점점 커져가고 있음**
- 하드웨어가 발달하며, 컬렉터가 메모리를 조금 더 사용하는건 문제가 안됨
- 하드웨어가 발달하고 좋은 사양의 하드웨어를 사용하면, 처리량이 늘어남

<br/>

지연시간은 그 반대
- 하드웨어의 발달로 메모리가 늘어나면, 청소해야 하는 양이 많아지니 지연 시간이 중가함

<br/>

종류
- Shenandoah
- ZGC

<br/>

## 번외

**엡실론 컬렉터 (Epsilon)**
- 가비지 컬렉션을 전혀 하지 않는 컬렉터
- 언제 / 왜 사용할까?
    - 가비지 컬렉터의 영향을 배제해야하는 성능 테스트, 스트레스 테스트에 이용
    - 서버리스: 서버리스 같이 짧은 시간 내 뜨고 죽는 경우, 기존 GC가 오버헤드. 동작 부하가 아주 적고 메모리 회수 활동이 전혀 없기에 적합함
- 찾아보니, 힙 꽉차면 OOM으로 서비스 다운된다고 보면 되는 듯

<br/>

## 적합한 가비지 컬렉터 선택하기

다양한 컬렉터들
- 다양한 서비스 상황들 → 적합한 컬렉터를 선택해 활용하는 것이 최고의 선택
- ‘적합한’을 어떻게 고를까? → 3가지 요인
    - (1) 애플리케이션의 주 목적이 무엇인가? (처리량/지연시간/메모리 사용량)
    - (2) 애플리케이션의 서브 시스템은 무엇인가? (하드웨어 아키텍처, 프로세서 개수 등)
    - (3) JDK Provider가 무엇인가? (OpenJDK, Oracle JDK, OpenJ9 등)

<br/>

약간의 꿀팁
- 최대 100MB 정도 작은 데이터 다룬다 → Serial
- 단일 프로세서만 사용하고, 일시 정지 시간 관련 제약이 없다 → Serial
- 애플리케이션 최대 성능 중요하고, 지연시간 관련 제약이 없다 → Default JVM Collector, Parallel Collector
- 처리량 보다 응답시간 중요하고, 일시 정지가 짧아야 한다 → G1
- 응답시간이 매우 중요하다 → ZGC
