- 사용되지 않는 객체를 자동으로 탐색하여 메모리를 자동으로 해제하는 과정
- 장점
	- 메모리 누수 방지 (Memory Leak Prevention)
	- 프로그래머가 직접 메모리를 관리할 필요 없음
- 왜 알아야 하는가?
	- 메모리 오버플로우, 누수 문제, 높은 동시성 상황에서 **자동화된**기능을 모니터링/조율할 수 있어야 하기 때문
# 대상이 죽었는가?

- 죽었다고 판단되는 객체 공간을 자동으로 정리한다. 이떄 죽었음을 판단하는 알고리즘이 여러가지가 있다.

## 참조 카운팅 알고리즘

- Python, Objective-C, Swift, PHP, Perl, JavaScript(예전 Internet Explorer의 COM Objects), Rust

#### Reference Count(참조 카운터)

1. 객체를 가리키는 `참조 카운터`를 추가한다.
2. 참조하는 곳이 늘어나면 `참조 카운터`의 값을 1 증가시킨다.
3. 참조하는곳이 줄어들면 `참조 카운터`의 값을 1 감소시킨다.
4. `참조 카운터`의 값이 0이된 객체는 더는 사용될 수 없다.

#### 장단점

- 즉시 메모리 해제 (Immediate Reclamation)
	- 참조 카운트가 0이 되는 즉시 메모리를 반환 
	- Stop-the-world GC 방식(Java GC)은 전체 애플리케이션을 멈추고 GC를 실행 하는데 그때그때 처리하니 이럴 필요 자체가 없다.
- 단순한 구현 가능 (Simple Implementation)
	- 객체마다 숫자 하나를 저장하는 방식으로 기본적인 메모리 관리 기법으로 쉽게 구현 가능
#### 순환 참조(circular reference) 문제

```python
class A:
    def __init__(self):
        self.ref = None

a = A()
b = A()
a.ref = b
b.ref = a  # 순환 참조 발생!

del a  # a 삭제
del b  # b 삭제해도 메모리 해제되지 않음!
```

- 더이상 도달할 방법이 없는 객체가 존재하여도 순환참조시 카운터가 0이되지 못하여 메모리가 정리되지 못하는 현상
- Python에서 해결
	- 약한 참조 (Weak Reference) 사용
	- 약한 참조는 참조카운트를 증가시키지 않아 강한참조가 모두 없어지면 회수의 대상이 된다.
```python
import weakref

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

node1 = Node(1)
node2 = Node(2)

# 약한 참조 생성
node1.next = weakref.ref(node2)
node2.next = weakref.ref(node1)
```

## 도달 가능성 분석 알고리즘

- JVM기반(Java, Kotlin), JavaScript(V8-chrome nodejs, SpiderMonkey-firefox), C#, Go
- GC 루드라고 하는 루트 객체들을 시작 노드 집합으로 사용하여 도달 불가능한 객체가 회수대상이 된다.
![[도달가능성-분석알고리즘.png]]
**도달 가능성 알고리즘을 JVM의 GC중심으로 설명한다!!**
#### JVM의 GC루트

- 스택에서 참조하는 객체
	- 스택이란건 현재 실행중이라는 뜻
	- 매개 변수(메소드 호출시 전달), 지역 변수(메소드 내부 선언), 임시 변수(JIT컴파일러가 임시생성) 모두 포함
- 정적 필드: static 키워드로 선언
- 상수: 문자열 테이블에서 참조
- 기타
	- 네이티브 메서드 스택(JNI)가 참조하는 객체
	- 가상머신 내부에서 쓰이는 참조
		- 기본 상주 예외: NullPointerException, OutOfMemoryError 등...
		- 시스템 클래스 로더
	- 동기화 락(synchronized 키워드)로 잠겨 있는 모든 객체
	- (선택적 기능)JMXBean: 가상머신 내부상황을 반영하고 모니터링관리 도구

- 메서드 영역(Method Area)은 GC 대상이 되어야 하는가?
	- 클래스 메타정보, 메서드 정보, 런타임 상수풀, static
	- 동적으로 클래스를 생성하게되는 리플렉션, 동적 proxy, CGLib, JSP 사용시 문제발생 가능성 있음

#### 도달가능하다(참조한다) 의미

- 도달 불가능 하지만 지금은 메모리가 충분하고 나중에 또 사용할 가능성이 있다면?
	- 나중에 회수하는게 성능상 유리하다
	- 개체들 사이에 회수 우선순위가 있을 수 있다.
##### 참조 우선순위

1. 강한참조(strong reference)
	1. 전통적으로 의미하는 일반적인 참조
	2. GC가 절대 회수하지 않음
2. 부드러운 참조(soft reference)
	1. `java.lang.ref.SoftReference`
	2. 유용하지만 필수는 아니다.
	3. 메모리 오버플로우 직전에 회수된다.
3. 약한 참조(weak reference)
	1. `java.lang.ref.WeakReference`
	2. 다음 GC전까지 살아남는다.
4. 유령 참조(phantom reference)
	1. `java.lang.ref.PhantomReference`
	2. 객체 수명에 영향을 주지 않는다.
	3. 객체가 회수될 때 알림을 받기 위함

##### 메서드 영역 회수
- 클래스 회수
	- 클래스 로더가 회수되어야 한다.
		- 클래스로더 <-> 클래스 서로 참조하고 있음
		- 클래스 내부에 자신을 로드한 ClassLoader에 대한 정보를 같이 가지고 있음
	- OSGi 모듈단위로 분리해 동적으로 관리하는 프레임워크
		- 모듈 제거시 해당모듈을 로드한 클래스로더와 클래스가 같이 삭제되어야함
	- JSP 리로딩: jsp 파일 변경시 서버에서 이를 감지하여 변경이 적용됨
		- 이전 jsp파일의 *_jsp.class 는 회수가 불가능함
		- 주기적으로 웹앱 전체를 리로딩하여 WebAppClassLoader 가 새로 생성되게 해야 클래스로더와 클래스가 같이 회수되도록 해야함
# 가비지 컬렉션 알고리즘

## 세대 단위 컬렉션 이론

### 기본 가설

1. 약한 세대 가설(weak generational hypothesis): 대다수 객체는 일찍 죽는다.
2. 강한 세대 가설(strong generational hypothesis): 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 오래 살 가능성이 커진다.

- 메모리를 여러개의 영역으로 나누고 객체의 나이에 따라 각기 다른 영역에 할당한다.
	- 곧 죽을 객체가 모인곳
		- new generation, eden
	- 오래동안 살아남은 객체가 모인곳
		- old generation
	- 죽을 가능성이 높은 공간부터 메모리를 회수하면 가성비 좋게 메모리를 회수할 수 있다.

### 추가된 가설

3. 세대 간 참조 가설(interfenerational reference hypothesis): 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

- 세대간 참조를 가진다의 의미
	- 구세대가 신세대 객체를 참조한다.
	- 구세대는 오래살아남기 때문에 다음번 GC에도 살아남는다
	- 살아남은 구세대가 참조하는 신세대 객체도 같이 살아남으면서 구세대로 승격된다.
	- 세대간 참조가 자연스럼게 사라진다.

- 아주 낮은 확률의 세대간 참조를 찾는건 비효율 적이다.
	- 구세대를 전체 탐색하는건 비효율 적이다.
	- 구세대에서 신세대에 대한 참조가 생기는시점에 기억해두면 효율적인 처리가 가능해진다
		- Card Table, Remembered Set 을 사용

- 세대 단위 컬렉션 종류
	- 부분 GC: 메모리(힙) 일부만회수
		- 마이너 GC(신세대 GC): 신세대만 대상
		- 메이저 GC(구세대 GC): 구세대만 대상, 문맥상 힙 전체회수를 의미하는 경우도 있음
		- 혼합 GC: 신세대, 구세대 일부를 대상 - G1 GC
	- 전체 GC: 메모리 전체(힙 + 메서드)를 대상

## 마크-스윕 알고리즘

![[마크-스윕알고리즘.png]]
실행과정
- 회수할 객체들에 모두 표시 후 -> 표시된 객체들을 쓸어 담는다.
- 반대로 하기도 한다: 살릴 객체 표시 후 -> 표시안된 객체를 쓸어담는다.

특징
- 대부분이 회수대상이면 비효율적이다.
	- 대부분을 표시하고, 대부분을 회수 -> 표시, 회수 대상이 많다
- 메모리 파편화가 심하다.
	- 큰 객체를 생성하려고 할때 시간이 지날수록 연속된 메모리를 찾기 어려워진다. -> 추가적인 GC 실행 유발

**회수 대상이 적을때 유리하다. 구세대에 유리**

## 마크-카피 알고리즘


![[마크-카피알고리즘.png]]
실행과정
1. 메모리를 두개의 블록으로 나눠서 한쪽 블럭만 사용한다.
2. 한쪽블럭이 꽉차면 살아남은 객체만 다른블럭으로 복사한다.
3. 기존블럭은 한번에 청소한다.

특징
- 대다수의 객체가 살아남는다면 비효율적이다.
	- 대부분의 객체를 복사해야한다.
- 메모리를 절반으로 줄여 낭비가 심하다.
- 단점 개선 알고리즘 - 아펠 스타일 컬렉션
	- 신세대 객체의 98%가 첫 GC에서 살아남지 못한다는 통계
	- 메모리 영역을 1:1로 나눌 필요없이 8:1로 나눠서 사용한다
	- 단점: 살아남는 객체가 10%이상이되면 공간이 옮겨 담을 공간이 부족해진다.

**회수 대상이 많을때 유리하다. 신세대에 유리**

## 마크-컴팩트 알고리즘

![[마크-컴팩트알고리즘.png]]
실행과정: 마크-스윕 알고리즘 + 이동
1. 회수할 객체들에 모두 표시
2. 생존한 객체를 메모리 영역의 한쪽 끝으로 모은다
3. 나머지 공간을 한꺼번에 비운다

마크-스윕 vs 마크-컴팩트
- 마크-스윕: 모으는 작업을 안한다
	- 메모리 파편화가 발생으로 메모리 할당시간이 길어진다.
	- stop the world(일시정지) 시간이 짧아진다.
	- 당장은 빠르지만 길게보면 시간이 더 든다
- 마크-컴팩트: 모으는 작업을 하면
	- 메모리 파편화 없어져서 메모리 할당시간이 짧아진다.
	- 생존객체를 참조하는 모든곳의 참조정보 갱신이 필요함
	- stop the world(일시정지) 시간이 길어진다.
	- 당장은 느리지만 길게보면 시간이 덜 든다
- 처리량을 우선시하냐? 일시 정지 시간을 우선시하냐?
	- 마크-스윕으로 작동하다가 메모리파편화가 어느정도 심해지면 마크-컴팩트로 작동한다.

# 핫스팟 알고리즘 구현

- 이후에 설명할 GC에서 사용하는 구체적인 기법 설명
## 루트 GC 열거

- 루트 GC: 실행 컨텍스트(실행스택)과 전역 참조(static), 등...
- 루트 GC 대상중 객체만 찾아내야 한다.
	- primitive는 참조가 없기 때문에 탐색이 필요없어서 루트 GC에서 제외된다.
## 정확한 메모리 관리

- 현대 JVM구현은 모두 정확한 메모리 관리 사용
- 메모리에 담긴 자료형이 어떤것인지 알수 있음
	- 32비트 메모리에 12345가 담겨있는경우 참조하는 객체의 주소인지? 그냥 숫자인지 메타데이터로 관리
	- 참조이면 계속 따라가고, 값이면 거기서 끝나는거고
- 방법: OopMap 자료구조
	- 객체 참조위치와 실제 객체 위치를 파악하기 위한 기록한 메타데이터
	- gc는 타입을 모른다 -> 메모리에 있는게 참조여서 GC루트로 따라가봐야하는 얘인지, primitive여서 따라갈 필요값없는 영역인지 알아야 한다
	- OopMap에서 해당 주소에 있는게 참조인지 primitive인지 미리 기록해두는 역할을 한다.

## 안전지점

- 참조관계, OopMap을 변경하는 무수히 많은 명령어가 존재한다.
- 모든 명령어에 OopMap을 생성하는 코드를 만들면 메모리 사용량이 너무 많아진다.
- 특정 위치(안전지점)에서만 OopMap을 수정한다.
	- GC는 사용자 스레드가 안전지점에 도달할 때까지는 기다린다
		- OopMap이 정상적인 값으로 수정되는것을 기다리는 것
- OopMap은 몇개나 만들까?
	- 메소드호출, loop, 예외처리 등에서 생성하여 너무 많은곳에서 생성하지 않도록 함
- 어떻게 멈출 것인가?
	- 사용자 스레드는 안전지점에 가까워 지면 멈춰야하는지를 polling하여 스스로 확인
	- 객체 생성시: 메모리 할당 못받는것을 예방하기 위해
- 안전지역
	- 멈춰있는(잠자는, 블록됨) 쓰레드는 스스로 polling이 불가능
	- 객체 참조 관계가 변하지 않음을 보장하는 범위를 의미
	- 안전 지역에 들어간 쓰레드는 GC가 신경쓰지않고 GC루트 열거가 가능함

## 영역간 참조

- dirty(더럽혀지다): 세대간 참조가 존재여부
- 기억집합
	- 비회수 영역(GC대상이 아님)에서 회수 영역(GC대상)를 가리키는 포인터를 기억하는것
	- 기억의 정밀도: 기억의 크기를 어느정도로 잘게 쪼게서 기억할 것이냐?
		- 크다-기억에 메모리가 적게든다, 어느곳이 세대간 참조인지 찾아야하는 범위가 넓어짐
		- 작다-반대!
	- JVM은 카드 정밀도 사용: 카드 하나는 메모리 블록 하나에 매핑됨
		- 해당메모리 블록에 세대간 참조를 가진 객체가 존재한다는 의미
- 카드 테이블: 카드 정밀도로 구현한 기억집합![[카드테이블.png]]
	- 더렵혀진 메모리안에 객체들에 대해서만 세대간 참조가 있는지 확인
- 쓰기장벽
	- 더렵혀지는지는 시점에 카드테이블에 기록해야한다.
	- 더렵혀지는 시점: 참조 타입 필드에 값이 대입되는 순간
	- 카드 테이블 쓰기작업중 false sharing 문제 발생![[false-sharing.png]]
		- [출처]( https://haryachyy.wordpress.com/2018/06/19/learning-dpdk-avoid-false-sharing/)
		- 64비트시 -> 카드테이블 원소하나가 1바이트로 64개 원소가 서로 성능에 영향을 준다
		- 더렵혀져서 카드테이블에 기록해야할때
			- 기존데이터를 확인하여 더렵혀지지 않은 경우에만 쓰기작업을 한다
		- padding을 사용한 해결 예시코드
```java
static class PaddedData {
	public volatile long value = 0L;
	public long p1, p2, p3, p4, p5, p6, p7, ...; // 쓸모없는 변수를 선언하여 빈공간 차지하게함
}
```

## 도달 가능성 분석

- GC 루트에서 도달가능한 객체를 탐색해가는 과정

#### 동시 접근 가능성 분석

- 기본적으로는 모든 쓰레드를 멈추고 일관성이 보장되는 스냅숏에서 접근가능한 객체를 찾는 과정을 진행해야한다.
- heap이 커지면 커질수록 탐색 시간이 증가한다.
- 사용자 스레드와 동시에 탐색시 에러케이스 두가지
	- 죽은걸 살았다고 표시: 다음GC에서 회수가능 치명적이지 않음
	- 살은걸 죽었다고 표시: 객체 사라짐 문제 발생, 치명적
		- 사용자 스레드에서 객체를 쓰려도하는데 회수해서 없어져 버림!!!
- 탐색과정
	- 흰색에서 회색을 거쳐 검은색으로 퍼져나가면서 탐색이 진행됨
	- 흰색: GC가 방문한적이 없음
	- 검은색: GC가 방문함, 참조스캔 완료
	- 회색: GC가 방문함, 이 객체를 참조하는 흰색이 존재함
- 살은걸 죽었다고 표시 발생 케이스 2가지
	- ![[동시접근가능성분석.png]]
	- 사용자 쓰레드가 흰색객체 생성후 검은색을 참조
	- 사용자 스레드가 회색객체에서 흰색 객체로의 직간접적인 참조를 삭제
- 두가지 상황을 기억해 뒀다가 탐색 종료후 한번터 탐색한다.
