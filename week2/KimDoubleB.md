리스프의 창시자인 존 맥카시는 ‘가비지 컬렉션이 처리해야 하는 문제’ 3가지를 생각해냈다.
- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

<br/>

그래서 이번 범위의 목차
- 대상이 죽었는가?
    - 참조 카운팅 알고리즘
    - 도달 가능성 분석 알고리즘
    - 참조 종류
    - 메서드 영역 회수하기
- 가비지 컬렉션 알고리즘
    - 세대 단위 컬렉션 이론
    - 마크-스윕 알고리즘
    - 마크-카피 알고리즘
    - 마크-컴팩트 알고리즘
- 핫스팟 알고리즘 상세 구현
    - 루트 노드 열거
    - 안전 지점/안전 지역
    - 기억 집합과 카드 테이블
    - 쓰기 장벽
    - 동시 접근 가능성 분석

<br/>


---

# 대상이 죽었는가?

가비지 컬렉터가 청소하기 위한 조건

어떤 객체가 살았고, 어떤 객체가 죽었는지 판단하기 위한 계산

<br/>

**(1) 참조 카운팅 알고리즘**
- 프로세스
    - 객체 가리키는 참조 카운터를 추가
        - 참조하는 곳 늘어날 때마다 카운터 증가
        - 참조하는 곳 없어질 때마다 카운터 감소
    - 카운터 0이 된 객체는 사용하는 곳 없음
- 순환참조 등 여러 문제상황을 해결하기 위해 고려해야할 게 많음. JVM에선 사용하지 않음

<br/>

**(2) 도달 가능성 분석 알고리즘**
- 프로세스
    - GC 루트 객체를 시작 노드 집합으로 이용
    - 참조하는 객체들을 탐색, 참조 체인(*GC루트와 객체 간 참조 경로*)을 만들어 감
    - 참조 체인이 없다는 건, 참조하는 객체가 없다는 것
- **GC 루트 객체**: 가비지 컬렉터, 메모리 영역에 따라 달라질 수 있음
    - Stack에서 참조하는 객체: *메서드 매개변수, 지역변수, 임시변수 등*
    - 메서드 영역에서 클래스가 정적 필드로 참조하는 객체: *참조 타입 정적 변수*
    - 메서드 영역에서 상수로 참조되는 객체: *문자열 테이블 안의 참조*
    - 네이티브 메서드 스택에서 JNI가 참조하는 객체
    - JVM 내부에서 쓰이는 참조: *Class 객체, 일부 예외 객체, 시스템 클래스 로더*
    - 동기화 락으로 잠겨 있는 모든 객체
    - JVM 내부 상황을 반영하는 JMXBean: *JVMTI에 등록된 콜백, 로컬 코드 캐시 등*
    - => GC루트는 힙 외부에서 시작한다 => 사용하는 메모리/영역/변수

<br/>

위 알고리즘에서 '참조'가 등장. 즉, 객체의 생사 판단과 '참조'는 뗄 수 없음.
JVM에서 참조는 **4가지**
- Strong Reference
    - 전통적인 정의의 참조. 프로그램 코드에서 직접 할당하는 것
    - **해당 참조가 남아있는 객체는 가비지 컬렉터가 절대 회수하지 않음**
- Soft Reference
    - 메모리 부족(OutOfMemoryError 직전) 상태가 되면, 객체를 수거
    - 캐시 데이터 같은 메모리가 부족할 때 수거해도 되는 데이터에 활용
- Weak Reference
    - 다음 번 가비지 컬렉션까지 살아 있는 객체
    - **메모리가 넉넉하더라도 가비지 컬렉터가 동작하면 모두 회수**
- Phantom Reference
    - 객체 수명과 연관 없고, 객체 인스턴스 가져오는 것마저도 불가능한 참조
    - 대상객체 회수 때 알림을 받기 위해 활용 (ex. 네이티브 리소스, DB 커넥션 해제 등)
        - 왜 알림을 받아? => 네이티브 리소스 자원 해제 등 후처리 작업 수행을 위함

<br/>

`finalize()`
- 왜 필요한가?
    - 개발자가 리소스 자원해제 호출(close) 하는 것을 잊었을 때를 대비하기 위한 것
    - 객체가 GC에 의해 수거하기 직전에 JVM이 finalize를 호출. 즉, finalize에 네이티브 자원 해제 같은 로직을 담아두면 개발자가 깜빡해도 정리가 될 것.
- 근데 왜 없어졌는가?
    - (1) 실행시점 불확실 (non-deterministic)
        - GC 실행시점을 확실히 알지 못하니, finalize도 언제 호출될지 모름.
        - 고로, 네이티브 리소스가 즉시 해제되지 않고, 한참동안 시스템에 남아있을 수 있음.
        - JVM 종료까지도 GC가 발생하지 않을 수도 있음. 즉, 영원히 호출되지 않을 수도 있음
    - (2) 성능 저하
        - finalize가 구현된 객체는 GC가 2번 돌아야 제거가 됨.
            - [1] 첫 번째 사이클에서 "finalizable"로 표시, 큐에 넣음
            - [2] Finalizer 스레드가 finalize 실행
            - [3] 두 번째 사이클에서 실제 수거
        - GC에 부담. 불필요한 오버헤드
    - (3) 객체 부활
        - finalize 메서드 내 `this` 객체를 static 변수에 할당하는 등 죽어가던 객체를 다시 살릴 수 있었음
        - GC 로직, 프로세스가 매우 복잡해짐
- 대체
    - 네이티브 자원해제 같은 중요한 작업을 '언제 실행될지 모르는' 동작에 의존하는 것이 잘못됨.
    - (1) `try-with-resources`
        - 결정론적 해제 방법
        - Code block 벗어나면 바로 자원 해제
    - (2) `Cleaner`
        - `PhantomReference` 기반으로 만들어짐
        - `finalize`의 단점은 제거하고 목적(안전망)만 달성
            - GC에 의해 완전히 수거된 후 동작
            - GC를 방해하지 않고, 객체를 살릴 수 없음
- 다시 책의 내용: 도달 가능성 분석을 통해 첫 번째 표시, 그 후 필터링
    - finalize는 이제 사용안함 -> 즉, 도달 가능성 알고리즘을 통해 마킹하고, 제거 대상 결정
- +) finalize를 필터링이라고 말하는 이유: 제거 마킹을 필터링 -> 유예함. 살려줄 기회.
- +) 아직 있긴 함. JDK 25에도 Deprecated annotation 붙은 채로 존재.

<br/>

메서드 영역 회수
- 더 이상 사용되지 않는 상수와 클래스 회수
- 상수: 객체 회수하는 방법과 유사
- 클래스: 아래 3가지 조건 만족하는 경우
    - 이 클래스의 인스턴스가 모두 회수되었다. 인스턴스가 힙에 존재하지 않는다.
    - 이 클래스를 읽어들인 클래스 로더가 회수되었다.
    - 이 클래스의 Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 활용하는 곳도 전혀 없다.
- Q. JVM 타입 언로딩 지원
    - Reflection, Dynamic Proxy, CGLib Bytecode, JSP, OSGi 환경 등

<br/>

## 가비지 컬렉션 알고리즘

세대 단위 컬렉션
- 근간인 두 가지 가설
    - 약한 세대 가설: 대다수의 객체는 일찍 죽는다.
    - 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
    - +) 세대 간 참조 가설: (구/신) 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
- **힙을 몇 개의 영역으로 나누고 객체들의 나이에 따라 각기 다른 영역에 할당하자**
    - 왜? >> 영역을 나누고, 가비지 컬렉터의 빈도를 다르게 최적화. 전체 시간도 줄고, 메모리 공간도 효율적으로 이용
    - 생존 특성에 따라 마크-스윕, 마크-카피, 마크-컴팩트 등 알고리즘을 구분해 적용

<br/>

3가지 알고리즘
- 마크-스윕: 표시하고 쓸기
    - 실행 효율 일정하지 않음
    - 메모리 파편화가 심함
- 마크-카피: 메모리 나눠 꽉차면 복사하고 비우기
    - 구현 쉽고, 실행 효율도 좋음. 하지만, 메모리 낭비가 있음
    - 신세대에서 이 알고리즘 대부분 활용. 복사할게 많으면 효율이 안좋음 => 구세대에 적합하진 않음.
    - 아펠 스타일: 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나누어 활용
- 마크-컴팩트: 표시하고, 컴팩트하고, 쓸기
    - 생존 객체를 한 쪽 끝으로 모으고 나머지 공간 비우기
    - 메모리 이동 -> 이동된 객체를 가리키던 참조 모두 갱신 필요 -> STW
    - 그렇다고 파편화 냅둬? => Trade off
        - 객체를 이동시키면 회수 작업이 복잡해짐
        - 객체를 이동시키지 않으면 객체 할당 작업이 복잡해짐 (파편화)
        - => **메모리 할당하고 접근하는 빈도가 가비지 컬렉션 수행 빈도보다 훨씬 많으므로 할당과 접근 효율이 떨어지면 전체적인 처리량이 나빠진다.**
    - 이러한 이유 때문에 마크-스윕을 사용하다가, 객체 할당에 영향 줄 만큼 파편화가 심해지면 마크-컴팩트를 이용해 연속된 공간을 확보하기도 함 (CMS 컬렉터)
        - 파편화가 심해진다? => Concurrent Mode Failure 발생
        - Concurrent Mode Failure: 구세대에 객체 할당을 실패한 경우 (연속된 빈 공간 찾지 못하는 경우)
        - 바로 Full GC 수행해서 마크-컴팩트 진행
