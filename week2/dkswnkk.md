# 『JVM 밑바닥까지 파헤치기』 3.1-3.4장 정리

## 1. 생존 객체 탐색 방법: '쓰레기'는 어떻게 결정되는가

GC의 첫 번째 임무는 힙(Heap) 메모리 영역에 존재하는 수많은 객체 중에서 어떤 것이 '살아있는(live)' 객체이고 어떤 것이 더 이상 사용되지 않는 '죽은(dead)' 객체, 즉 쓰레기인지를 판별하는 것이다. 이 판별 기준과 과정의 정확성 및 효율성이 전체 GC 성능을 좌우한다.

### 1.1. 참조 카운팅(Reference Counter)

GC 알고리즘 중에는 각 객체에 참조 카운터(Reference Counter)를 두어, 자신을 참조하는 변수가 생길 때마다 카운트를 1 증가시키고 참조가 해제될 때마다 1 감소시키는 **'참조 카운팅(Reference Counting)'** 방식이 있다. 카운터가 0이 되면 해당 객체를 쓰레기로 간주하는 직관적인 방식이지만, 두 개 이상의 객체가 서로를 참조하는 **'순환 참조(Circular Reference)'** 상황을 해결하지 못하는 치명적인 결함이 있다. 이 경우, 외부에서는 두 객체에 접근할 방법이 없어 명백한 쓰레기임에도 불구하고 서로의 참조 카운터가 0이 되지 않아 영원히 메모리에서 해제되지 않는 문제가 발생한다.

**자바에서는, 적어도 자바 가상 머신에서는 참조 카운팅을 쓰지 않는다.**

### 1.2. 도달 가능성 분석 (Reachability Analysis): The Core Principle

**자바, C# 등 오늘날의 주류 프로그래밍 언어들은 도달 가능성 분석(Reachability Analysis) 알고리즘을 사용한다.** 이 알고리즘의 핵심 아이디어는 'GC Roots'라고 불리는 특별한 시작 객체들의 집합에서부터 경로 체인(Reference Chain, 탐색 과정에서 만들어지는 경로를 의미)을 따라가며 객체 그래프를 순회하는 것이다. 이 과정에서 GC Roots로부터 시작하여 도달할 수 있는 모든 객체는 '살아있는' 객체로 간주되며, 도달할 수 없는 객체는 모두 쓰레기로 판별되어 수거 대상이 된다. **이 방식은 순환 참조 문제가 발생하더라도, 해당 객체 그룹이 GC Roots로부터 도달할 수 없다면 모두 쓰레기로 정확하게 식별할 수 있다.**

### 1.3. GC Roots: 탐색의 시작점

도달 가능성 분석의 출발점이 되는 GC Roots는 힙 외부에 존재하면서 힙 내부의 객체를 참조하는 특별한 객체 또는 변수들이다. GC는 이들이 항상 살아있다고 가정하고 탐색을 시작하며, 주요 GC Roots는 다음과 같다.

- **JVM 스택(Stack) 내 참조**: 현재 실행 중인 메서드의 스택 프레임에 존재하는 지역 변수, 파라미터, 임시 변수 등이 참조하는 힙 상의 객체들이다. 메서드 실행이 끝나면 스택 프레임이 사라지므로 이 참조도 함께 사라진다

- **메서드 영역(Method Area)의 정적(Static) 변수 참조**: 클래스의 정적 변수(static 필드)가 참조하는 객체들이다. 이 변수들은 클래스가 로딩될 때 생성되어 애플리케이션이 종료될 때까지 유지되므로, 이들이 참조하는 객체 역시 생명주기가 길다.

- **메서드 영역의 상수(Constant)참조**: 문자열 리터럴과 같은 상수 풀 내부의 참조가 가리키는 객체들이다.

- **JNI(Java Native Interface) 참조**: 네이티브 코드(C/C++ 등)에서 생성했거나 참조하고 있는 자바 객체들이다. JVM 외부의 코드에 의해 생명주기가 관리되므로 GC Roots로 취급된다.

- **동기화 락(Synchronization Lock)에 의해 잠긴 객체**: synchronized 키워드를 통해 모니터 락(monitor lock)으로 사용되고 있는 객체는 스레드가 해당 락을 소유하고 있는 동안 살아있는 것으로 간주된다.

### 1.4. 참조의 종류와 객체의 생명주기

자바에서 '참조'는 단순히 객체에 도달할 수 있는지 여부를 나타내는 이분법적인 개념이 아니다. 참조의 '강도'에 따라 객체의 생존 여부가 달라지며, 이를 통해 개발자는 메모리 사용을 더 정교하게 제어할 수 있다. **객체의 생명주기는 단순한 '도달 가능성'을 넘어, 어떤 종류의 참조로 연결되어 있는지에 따라 결정된다.**

- **강한 참조(Strong Reference)**: `Object obj = new Object();`와 같이 일반적인 모든 참조를 의미한다. 강한 참조가 하나라도 연결되어 있는 객체는 GC의 대상이 되지 않는다.

- **부드러운 참조(Soft Reference)**: `java.lang.ref.SoftReference` 클래스로 구현된다. **부드러운 참조만으로 도달 가능한 객체는 힙 메모리가 부족하여 OutOfMemoryError가 발생하기 직전에 수거된다.** 즉, 메모리가 충분할 때는 살아남지만, 부족해지면 제거되는 '유용하지만 필수는 아닌' 객체를 표현한다.

- **약한 참조(Weak Reference)**: `java.lang.ref.WeakReference` 클래스로 구현된다. 부드러운 참조보다 더 약한 참조로, 약한 참조만으로 도달 가능한 객체는 메모리 상황과 관계없이 다음 GC가 실행될 때 항상 수거된다.

- **유령 참조(Phantom Reference)**: `java.lang.ref.PhantomReference` 클래스로 구현되며 가장 약한 참조이다. 이 참조는 객체의 생존에 아무런 영향을 주지 않으며, 이를 통해 객체 인스턴스를 얻는 것도 불가능하다. 유일한 목적은 객체가 `finalize` 메서드 실행 후 메모리에서 완전히 해제되기 직전에 `ReferenceQueue`에 통지를 보내, 자원 정리와 같은 후처리 작업을 수행할 수 있도록 하는 것이다.

### 1.5. 메서드 영역의 메모리 회수

GC의 작업 범위는 힙에만 국한되지 않는다. **클래스의 메타데이터, 정적 변수, 상수 풀 등이 저장되는 메서드 영역(Java 8 이후로는 Metaspace) 또한 GC의 대상이 된다.** 이곳에서의 주요 수거 대상은 더 이상 사용되지 않는 '상수'와 '클래스'이다.
상수 회수는 힙 객체와 유사하게, 더 이상 어떤 곳에서도 참조되지 않을 때 발생한다. 반면, 클래스 언로딩(Unloading)은 매우 엄격한 조건을 만족해야만 가능하기에 흔하게 발생하지 않는다. 다음 세 가지 조건을 동시에 만족해야 한다.

- 해당 클래스의 모든 인스턴스가 힙에서 완전히 제거되어야 한다.
- 해당 클래스를 로딩한 ClassLoader가 수거 대상이 되어야 한다.
- 해당 클래스에 대한 `java.lang.Class` 객체가 어디에서도 참조되지 않아야 한다(ex: 리플렉션을 통해 사용되지 않아야 함).

이 세 가지 조건을 모두 만족해야만 클래스 메타데이터가 메서드 영역에서 제거될 수 있다. 다만 이 **세 조건에 부합할때 제거를 '허용'한다고 했지, 반드시 회수하는 것은 아니다.**

## 2. 가비지 컬렉션 핵심 알고리즘

쓰레기 대상을 식별했다면, 다음 단계는 이들을 효율적으로 메모리에서 제거하는 것 이다. 모든 현대적인 GC는 몇 가지 기본적인 알고리즘을 조합하고 변형하여 구현된다.

### 2.1. 세대 가설: GC 설계의 근간

현재 상용 가상머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초해 설계되었다. 기본 적으로 아래의 두 가지 가정이 뿌리를 이룬다.

- **약한 세대 가설(Weak Generational Hypothesis)**: 대부분의 객체는 생성된 지 얼마 되지 않아 쓰레기가 된다. 즉, '단명'하는 객체가 대다수이다.

- **강한 세대 가설(Strong Generational Hypothesis)**: 여러 번의 GC에서 살아남은 객체는 앞으로도 계속 살아남을 가능성이 높다. 즉, '장수'하는 객체는 계속 장수한다.

세대 단위 컬렉션 이론을 가상 머신에 적용한 설계자들은 자바 힙을 최소 두개 영역으로 나눈다. 이를 나눈게 **'신세대(마이너 GC)'와 '구세대(메이저 GC)'** 이다.

다만 신세대에서만 가비지 컬렉션을 하고 싶더라도, 신세대에 속하지만 구세대에서 참조 중인 객체도 충분히 있을 수 있다. 따라서 살아남을 객체를 찾으려면 도달 가능성을 분석할 때 고정된 GC 루트들뿐 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰할 수 있다. 반대도 마찬가지다. 다만 **구세대 전체의 객체들까지 탐색한다는게 이론적으로야 가능하지만 성능 면에서는 부담이 크기때문에 세대 단위 컬렉션 이론에 세 번째 경험 법칙을 추가한다.**

- **세대 간 참조 가설(Inter-Generational Reference Hypothesis)**: 오래된 세대의 객체가 젊은 세대의 객체를 참조하는 경우는 매우 드물다.

이러한 가설들은 중요한 설계적 결론으로 이어진다. 모든 객체를 동일하게 취급하는 대신, **객체의 '나이'(GC에서 살아남은 횟수)에 따라 물리적으로 다른 메모리 공간에 배치하여 관리하는 것이 효율적이라는 것이다.** 이 아이디어는 JVM 힙을 **Young Generation(젊은 세대)**과 **Old Generation(늙은 세대)** 으로 분리하는 구조를 탄생시켰다.

- **Young Generation**: 새로 생성된 객체들이 할당되는 공간이다. 약한 세대 가설에 따라 대부분의 객체가 여기서 쓰레기가 되므로, 작고 빈번한 Minor GC가 발생한다.

- **Old Generation**: Young Generation에서 여러 번의 Minor GC를 거치고도 살아남은 '장수' 객체들이 이동(Promotion)되는 공간이다. 이곳의 객체들은 오랫동안 살아남을 확률이 높으므로, 크고 드물게 발생하는 Major GC 또는 Full GC의 대상이 된다.

이러한 세대 구분 구조는 GC가 전체 힙을 매번 스캔하는 비효율을 피하고, 쓰레기가 많이 발생할 것으로 예상되는 Young Generation에 집중하여 빠르고 효율적으로 메모리를 회수할 수 있게 해준다. 그리고 **드물게 발생하는 Old Generation에서 Young Generation으로의 참조**는 **'카드 테이블(Card Table)' 또는 '기억 집합(Remembered Set)'** 이라는 자료 구조를 통해 별도로 기록하여, **Minor GC 시 전체 Old Generation을 스캔하지 않고도 참조 관계를 파악할 수 있도록 돕는다.**

### 2.2. Mark-Sweep 알고리즘

가장 기본적인 추적(Tracing) GC 알고리즘으로, 이름처럼 두 단계로 동작한다. 

- **Mark(표시) 단계**: GC Roots에서부터 시작하여 도달 가능한 모든 객체를 찾아 '살아있음'을 표시한다.

- **Sweep(쓸기) 단계**: 힙 전체를 스캔하면서 표시되지 않은 모든 객체(쓰레기)가 차지하던 메모리를 해제한다.

이 알고리즘의 가장 큰 단점은 **메모리 파편화(Memory Fragmentation)** 이다.

**Sweep 단계 이후 힙에는 회수된 메모리 공간이 여기저기 흩어져 있는 '구멍' 형태로 남게 된다.** 이로 인해 **사용 가능한 총 메모리 공간은 충분하더라도, 연속된 큰 메모리 공간이 없어 큰 객체를 할당하지 못하는 상황이 발생** 할 수 있다. 또한, 힙에 살아있는 객체가 많을수록 Mark와 Sweep 단계 모두에서 거의 전체 힙을 순회해야 하므로 효율성이 떨어진다.

### 2.3. Mark-Copy 알고리즘

**Mark-Sweep의 파편화 문제를 해결하기 위해 고안된 알고리즘** 이다. 이 방식은 가용 메모리 영역을 동일한 크기의 두 공간, 예를 들어 'From' 공간과 'To' 공간으로 나눈다. 객체 할당은 From 공간에서만 이루어진다. 그리고 GC가 발생하면 다음과 같이 동작한다.
- From 공간에 있는 살아있는 모든 객체를 식별한다. 이 살아있는 객체들을 To 공간으로 순서대로 복사(Copy)하여 연속된 메모리 공간에 배치한다.

- From 공간에 남아있는 모든 객체는 쓰레기이므로, From 공간 전체를 한 번에 깨끗하게 비운다.다음 GC 사이클에서는 두 공간의 역할이 바뀌어, To 공간이 새로운 From 공간이 된다.

이 알고리즘은 약한 세대 가설이 적용되는 Young Generation에 매우 적합하다. 대부분의 객체가 쓰레기이므로 소수의 생존 객체만 복사하면 되기 때문에 매우 빠르다. HotSpot VM은 이를 Eden 영역 1개와 Survivor 영역 2개(S0, S1)로 구현하여, Eden과 S0에 있던 생존 객체를 S1으로 복사하는 방식으로 동작한다.

하지만 이 알고리즘은 항상 전체 공간의 절반을 비워둬야 하므로 메모리 낭비가 심하다는 단점이 있다. HotSpot VM은 Eden과 Survivor의 비율을 8:1:1 등으로 조절하여 이 낭비를 약 10% 수준으로 최소화한다.

### 2.4. Mark-Compact 알고리즘

**Mark-Copy 알고리즘은 생존율이 높은 Old Generation에는 비효율적이다.** 대부분의 객체를 복사해야 하므로 비용이 크기 때문이다. 이 문제를 해결하기 위해 Mark-Compact 알고리즘이 사용된다. 이 알고리즘은 Mark-Sweep과 유사하지만 추가적인 단계를 가진다.

- **Mark(표시) 단계** : Mark-Sweep과 동일하게 살아있는 객체를 모두 표시한다.

- **Compact(압축) 단계** : 모든 살아있는 객체들을 메모리 영역의 한쪽 끝으로 차례대로 이동시켜(slide) 연속된 공간에 배치한다. 이 과정에서 이동된 객체를 참조하던 모든 변수의 주소 값도 함께 갱신해야 한다.

- 마지막으로, 살아있는 객체들 뒤에 남은 공간 전체를 한 번에 해제한다.

**이 방식은 파편화를 해결하면서도 Mark-Copy처럼 메모리를 낭비하지 않아 Old Generation에 적합하다.** 하지만 가장 큰 단점은 압축 단계의 비용이 매우 높다. 수많은 객체를 이동시키고 그에 대한 모든 참조를 수정하는 작업은 애플리케이션을 완전히 멈추는 Stop-The-World(STW) 시간을 길게 만든다.

결론적으로, JVM의 세대별 힙 구조는 각 알고리즘의 장단점을 최적으로 활용하기 위해 생겨났다. 생존율이 낮은 **Young Generation에서는 빠른 Mark-Copy** 를, 생존율이 높은 **Old Generation에서는 공간 효율적인 Mark-Compact(또는 파편화를 감수하는 Mark-Sweep)** 를 사용하여 전체 GC 효율을 극대화하는 것이다.

| 알고리즘 | 주요 목표 | 장점 | 단점 | HotSpot VM에서의 주 사용처 |
|-----------|-------------|-------|-------|------------------------------|
| **Mark-Sweep** | 단순성, 메모리 회수 | 구현이 간단하고 객체 이동 오버헤드가 없음 | 심각한 메모리 파편화 발생, 힙이 찰수록 효율 저하 | CMS와 같은 구형 GC의 Old Generation 수집 방식 |
| **Mark-Copy** | 파편화 제거, 빠른 수집 | 생존율이 낮을 때 매우 빠름, 연속된 가용 메모리 확보 | 메모리 공간의 일부를 항상 낭비함 | Young Generation 수집 (Minor GC) |
| **Mark-Compact** | 파편화 제거 및 공간 효율 | 메모리 사용 효율이 높고 파편화가 없음 | 객체 이동 및 참조 업데이트로 인한 긴 ‘Stop-The-World’ | Old Generation 수집 (Major GC/Full GC) |



## 3. HotSpot VM의 알고리즘 구현 심층 탐구

### 3.1. 루트 노드 열거

GC가 정확하게 동작하려면, 분석을 시작하는 시점의 메모리 상태가 일관성을 유지해야 한다. **만약 애플리케이션 스레드가 계속 실행되면서 객체 간의 참조 관계를 바꾸는 와중에 GC가 객체 그래프를 순회한다면, 살아있는 객체를 쓰레기로 오인하거나(데이터 유실) 쓰레기를 살아있는 객체로 착각하는(메모리 누수) 심각한 문제가 발생할 수 있다.**

이러한 '일관성 있는 스냅샷'을 확보하기 위해, GC는 루트 노드 열거(GC Roots에서부터 참조를 따라가는 초기 작업)를 시작하기 전에 반드시 모든 애플리케이션 스레드를 일시적으로 중지시켜야 한다. 이것이 바로 **Stop-The-World(STW)** 의 본질이다. CMS, G1, ZGC와 같은 최첨단 동시(Concurrent) 컬렉터조차도 이 초기 루트 열거 단계에서의 짧은 STW는 피할 수 없다. **현대 GC의 목표는 STW를 완전히 없애는 것이 아니라, 그 시간을 밀리초(ms) 단위, 혹은 그 이하로 줄이는 것이다.**

### 3.2. 안전 지점과 안전 지역

애플리케이션 스레드를 아무 명령어에서나 임의로 멈추는 것은 매우 복잡하고 위험하다. 스레드가 JVM 내부 자료 구조를 업데이트하는 중간에 멈출 경우 시스템 전체가 불안정한 상태에 빠질 수 있기 때문이다. 또한, 모든 명령어 위치에서 GC가 가능하도록 관련 메타데이터(어떤 변수가 참조인지 등)를 생성하는 것은 엄청난 오버헤드를 유발한다.

HotSpot VM(가장 널리 사용되는 자바 가상 머신은 이 문제에 대한 해법으로 안전 지점(Safe Point)이라는 개념을 도입했다.

**안전 지점이란 코드 실행 중 스레드를 멈추더라도 JVM의 상태가 안정적이고 예측 가능하도록 보장된 특정 위치를 말한다.** JIT 컴파일러는 메서드 호출, 루프의 끝(back-edge), 예외 발생 지점 등 실행이 길어질 가능성이 있는 곳에 안전 지점을 삽입한다. 그리고 **GC는 스레드가 이 안전 지점에 도달했을 때만 스레드를 중지시킬 수 있다.**

```
Q:근데 모든 스레드를 중단 시키는게 아닌가..? 특정 스레드들만 순차적으로 정지시키는게 stop the world 인가..?
A: GC는 모든 애플리케이션 스레드가 각자의 안전 지점에 도달하여 멈출 때까지 기다린다고 함.
 실제로 'Stop-The-World'가 시작되기까지 걸리는 시간은 가장 마지막 스레드가 안전 지점에 도달할 때까지 기다리는 시간을 포함하기에 특정 스레드 하나가 안전 지점에 늦게 도착하면 전체 GC 작업이 그만큼 지연될 수 있음
```

 **안전 영역(Safe Region)은 한 걸음 더 나아가, JNI 코드 실행과 같이 특정 코드 블록을 실행하는 동안에는 객체 참조 관계가 절대 변하지 않음을 보장하는 영역을 의미** 한다. 스레드가 안전 영역 안에 있을 경우, GC는 해당 스레드를 멈출 필요 없이 작업을 진행할 수 있다.

### 3.3. 스레드 중단 메커니즘

그렇다면 JVM은 어떻게 모든 스레드를 가장 가까운 안전 지점으로 유도하여 멈추게 할까? 강제로 모든 스레드에 인터럽트를 거는 '선제적 중단(Preemptive Suspension)' 방식은 비효율적이다. 대신 HotSpot VM은 훨씬 우아한 자발적 중단(Voluntary Suspension) 모델을 사용한다.

이 방식은 일종의 폴링(Polling) 메커니즘에 기반하는데, GC가 필요할 때 JVM은 특정 전역 플래그를 설정한다. 모든 애플리케이션 스레드는 실행 중에 안전 지점을 지날 때마다 이 플래그를 확인하는 코드를 실행한다. 만약 플래그가 설정된 것을 발견하면, 스레드는 스스로 실행을 멈추고 대기 상태에 들어간다.

이 폴링 작업은 매우 빈번하게 일어나므로 극도로 효율적이어야 한다. HotSpot VM은 특정 메모리 페이지에 대한 접근을 이용하는 하드웨어 트랩을 사용한다. **평소에는 이 페이지를 읽는 test 어셈블리 명령어가 아무 비용 없이 통과하지만, GC가 STW를 유발해야 할 때 JVM은 해당 메모리 페이지에 대한 접근 권한을 막아버린다. 그러면 test 명령어를 실행하는 스레드는 메모리 보호 폴트(fault)를 발생시키고, 미리 등록된 운영체제의 예외 핸들러가 이를 감지하여 해당 스레드를 안전하게 중단시킨다.** 이 덕분에 평상시의 폴링 오버헤드는 거의 0에 가깝게 된다. (이게 무슨 말인지 잘 모르겠음)

### 3.4. OopMaps

스레드가 안전 지점에서 멈췄다고 해도, GC는 해당 스레드의 스택과 CPU 레지스터의 수많은 데이터 중에서 어떤 것이 힙 객체를 가리키는 참조이고 어떤 것이 단순한 정수 값인지 즉시 알아내야 한다.

이 문제를 해결하기 위해 **JIT 컴파일러는 코드를 네이티브 코드로 컴파일할 때 각 안전 지점마다 OopMap이라는 특별한 메타데이터를 함께 생성한다.** OopMap은 해당 안전 지점에서 스택의 어떤 슬롯과 어떤 레지스터가 객체 참조를 담고 있는지를 정확하게 알려주는 역할을 한다.

스레드가 안전 지점에서 멈추면, GC는 해당 위치의 OopMap을 참조하여 단번에 모든 로컬 GC Roots를 식별할 수 있다. 스택 전체를 보수적으로 스캔하며 참조인지 아닌지 추측할 필요가 없어지는 것이다. 이 OopMap 덕분에 STW의 핵심 작업인 루트 노드 열거가 극적으로 빨라지며, 이는 전체 GC 성능 향상에 결정적인 기여를 한다.
