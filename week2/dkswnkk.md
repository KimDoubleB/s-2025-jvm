『JVM 밑바닥까지 파헤치기』 3.1-3.4장 정리


서론: 자동 메모리 관리의 심장, 가비지 컬렉션

자바(Java)가 플랫폼 독립성과 높은 개발 생산성을 달성할 수 있었던 핵심 기술 중 하나는 단연 자동 메모리 관리(Automatic Memory Management)입니다. 이 자동화의 중심에는 가비지 컬렉션(Garbage Collection, GC)이라는 정교한 메커니즘이 자리 잡고 있습니다. GC는 개발자가 C/C++와 같은 비관리 언어(Un-managed language)에서 직접 수행해야 했던 malloc/free와 같은 수동 메모리 할당 및 해제 작업을 JVM(Java Virtual Machine)이 대신 처리해주는 기능입니다.1
이러한 자동화는 개발자를 메모리 누수(Memory Leak)나 이중 해제(Double Free)와 같은 고질적인 버그로부터 해방시켜 비즈니스 로직 구현에만 집중할 수 있도록 돕습니다.2 그러나 이 편리함에는 대가가 따릅니다. GC는 JVM 내부의 백그라운드 프로세스(또는 스레드)로 동작하며, 애플리케이션 실행에 영향을 미칠 수 있는 오버헤드를 발생시킵니다.1 GC가 동작하는 동안 애플리케이션이 일시적으로 멈추는 현상(Stop-The-World)은 응답 시간(Latency)에 민감한 서비스에서 심각한 성능 저하의 원인이 되기도 합니다.2
따라서 현대적인 자바 애플리케이션 개발자에게 GC는 더 이상 '알아서 잘 동작하는' 블랙박스가 아닙니다. 애플리케이션의 성능을 극한까지 끌어올리고 안정성을 확보하기 위해서는 GC가 어떤 원리로 동작하는지, '쓰레기(Garbage)'를 어떻게 판별하고 수거하는지, 그리고 이 과정에서 어떤 비용이 발생하는지를 깊이 있게 이해해야 합니다. 본 문서는 『JVM 밑바닥까지 파헤치기』 3장의 핵심 내용인 3.1절부터 3.4절까지를 기반으로, GC의 근본적인 작동 원리와 세계에서 가장 널리 사용되는 HotSpot VM의 구체적인 구현 방식을 심층적으로 분석하여 제공합니다.

1. 생존 객체 탐색 방법: '쓰레기'는 어떻게 결정되는가

GC의 첫 번째 임무는 힙(Heap) 메모리 영역에 존재하는 수많은 객체 중에서 어떤 것이 '살아있는(live)' 객체이고 어떤 것이 더 이상 사용되지 않는 '죽은(dead)' 객체, 즉 쓰레기인지를 판별하는 것입니다. 이 판별 기준과 과정의 정확성 및 효율성이 전체 GC 성능을 좌우합니다.

1.1. 도달 가능성 분석 (Reachability Analysis): The Core Principle

초기 GC 알고리즘 중에는 각 객체에 참조 카운터(Reference Counter)를 두어, 자신을 참조하는 변수가 생길 때마다 카운트를 1 증가시키고 참조가 해제될 때마다 1 감소시키는 '참조 카운팅(Reference Counting)' 방식이 있었습니다. 카운터가 0이 되면 해당 객체를 쓰레기로 간주하는 직관적인 방식이지만, 두 개 이상의 객체가 서로를 참조하는 '순환 참조(Circular Reference)' 상황을 해결하지 못하는 치명적인 결함이 있습니다.1 이 경우, 외부에서는 두 객체에 접근할 방법이 없어 명백한 쓰레기임에도 불구하고 서로의 참조 카운터가 0이 되지 않아 영원히 메모리에서 해제되지 않는 문제가 발생합니다.
이러한 문제 때문에 현재 대부분의 상용 JVM, 포함하여 HotSpot VM은 도달 가능성 분석(Reachability Analysis) 알고리즘을 사용합니다.6 이 알고리즘의 핵심 아이디어는 'GC Roots'라고 불리는 특별한 시작 객체들의 집합에서부터 참조 체인(Reference Chain)을 따라가며 객체 그래프를 순회하는 것입니다.4 이 과정에서 GC Roots로부터 시작하여 도달할 수 있는 모든 객체는 '살아있는' 객체로 간주되며, 도달할 수 없는 객체는 모두 쓰레기로 판별되어 수거 대상이 됩니다.2 이 방식은 순환 참조 문제가 발생하더라도, 해당 객체 그룹이 GC Roots로부터 도달할 수 없다면 모두 쓰레기로 정확하게 식별할 수 있습니다.

1.2. GC Roots: 탐색의 시작점

도달 가능성 분석의 출발점이 되는 GC Roots는 힙 외부에 존재하면서 힙 내부의 객체를 참조하는 특별한 객체 또는 변수들입니다.8 GC는 이들이 항상 살아있다고 가정하고 탐색을 시작합니다. 주요 GC Roots는 다음과 같습니다 6:
JVM 스택(Stack) 내 참조: 현재 실행 중인 메서드의 스택 프레임에 존재하는 지역 변수, 파라미터, 임시 변수 등이 참조하는 힙 상의 객체들입니다. 메서드 실행이 끝나면 스택 프레임이 사라지므로 이 참조도 함께 사라집니다.
메서드 영역(Method Area)의 정적(Static) 변수 참조: 클래스의 정적 변수(static 필드)가 참조하는 객체들입니다. 이 변수들은 클래스가 로딩될 때 생성되어 애플리케이션이 종료될 때까지 유지되므로, 이들이 참조하는 객체 역시 생명주기가 깁니다.
메서드 영역의 상수(Constant) 참조: 문자열 리터럴과 같은 상수 풀 내부의 참조가 가리키는 객체들입니다.
JNI(Java Native Interface) 참조: 네이티브 코드(C/C++ 등)에서 생성했거나 참조하고 있는 자바 객체들입니다. JVM 외부의 코드에 의해 생명주기가 관리되므로 GC Roots로 취급됩니다.
동기화 락(Synchronization Lock)에 의해 잠긴 객체: synchronized 키워드를 통해 모니터 락(monitor lock)으로 사용되고 있는 객체는 스레드가 해당 락을 소유하고 있는 동안 살아있는 것으로 간주됩니다.

1.3. 참조의 종류와 객체의 생명주기

자바에서 '참조'는 단순히 객체에 도달할 수 있는지 여부를 나타내는 이분법적인 개념이 아닙니다. 참조의 '강도'에 따라 객체의 생존 여부가 달라지며, 이를 통해 개발자는 메모리 사용을 더 정교하게 제어할 수 있습니다. 객체의 생명주기는 단순한 '도달 가능성'을 넘어, 어떤 종류의 참조로 연결되어 있는지에 따라 결정됩니다. 이는 객체의 '생존'이 절대적인 상태가 아니라, JVM의 메모리 상황과 개발자의 의도에 따라 달라지는 확률적이고 유연한 상태임을 시사합니다.
강한 참조(Strong Reference): Object obj = new Object();와 같이 일반적인 모든 참조를 의미합니다. 강한 참조가 하나라도 연결되어 있는 객체는 GC의 대상이 되지 않습니다.6
부드러운 참조(Soft Reference): java.lang.ref.SoftReference 클래스로 구현됩니다. 메모리에 민감한 캐시(Cache) 등을 구현할 때 유용합니다. 부드러운 참조만으로 도달 가능한 객체는 힙 메모리가 부족하여 OutOfMemoryError가 발생하기 직전에 수거됩니다. 즉, 메모리가 충분할 때는 살아남지만, 부족해지면 제거되는 '유용하지만 필수는 아닌' 객체를 표현합니다.6
약한 참조(Weak Reference): java.lang.ref.WeakReference 클래스로 구현됩니다. 부드러운 참조보다 더 약한 참조로, 약한 참조만으로 도달 가능한 객체는 메모리 상황과 관계없이 다음 GC가 실행될 때 항상 수거됩니다.6
유령 참조(Phantom Reference): java.lang.ref.PhantomReference 클래스로 구현되며 가장 약한 참조입니다. 이 참조는 객체의 생존에 아무런 영향을 주지 않으며, 이를 통해 객체 인스턴스를 얻는 것도 불가능합니다. 유일한 목적은 객체가 finalize 메서드 실행 후 메모리에서 완전히 해제되기 직전에 ReferenceQueue에 통지를 보내, 자원 정리와 같은 후처리 작업을 수행할 수 있도록 하는 것입니다.6

1.4. Finalization: 최후의 탈출 기회

도달 가능성 분석에서 어떤 객체가 GC Roots로부터 도달 불가능하다고 판명되더라도 즉시 사망 선고를 받지는 않습니다. 해당 객체는 일종의 '유예 기간'을 가지며, 최소 두 번의 마킹(Marking) 과정을 거쳐야 최종적으로 메모리에서 제거됩니다.6
1차 마킹: GC는 도달 불가능한 객체들을 식별하여 1차적으로 마킹합니다.
Finalization 대상 필터링: 1차 마킹된 객체들 중에서, 해당 객체의 finalize() 메서드가 재정의(override)되어 있고 아직 한 번도 호출된 적이 없는지를 검사합니다.
F-Queue 등록: finalize() 메서드를 실행해야 하는 객체는 F-Queue라는 특별한 큐에 등록됩니다. JVM은 이 큐에 담긴 객체들의 finalize() 메서드를 실행하기 위해 낮은 우선순위를 가진 'Finalizer' 스레드를 실행합니다.6
객체의 부활(Resurrection): 개발자는 finalize() 메서드 내부에서 해당 객체(this)를 다른 살아있는 객체나 GC Roots에 연결하는 코드를 작성할 수 있습니다. 만약 이 과정에서 객체가 다시 참조 체인에 연결되면, 다음 GC 사이클에서는 '살아있는' 객체로 판명되어 수거 대상에서 제외됩니다. 이것이 객체의 '부활'입니다.6
하지만 finalize() 메커니즘은 실행 시점이 불확실하고 성능에 악영향을 주며, 자칫 잘못 사용하면 객체 부활로 인한 메모리 누수를 유발할 수 있는 매우 위험한 기능입니다. 이러한 문제점 때문에 자바 9부터는 공식적으로 deprecated 되었으며, 자원 해제가 필요한 경우에는 try-with-resources 구문과 AutoCloseable 인터페이스를 사용하는 것이 강력히 권장됩니다.6

1.5. 메서드 영역의 메모리 회수

GC의 작업 범위는 힙에만 국한되지 않습니다. 클래스의 메타데이터, 정적 변수, 상수 풀 등이 저장되는 메서드 영역(Java 8 이후로는 Metaspace) 또한 GC의 대상이 됩니다. 이곳에서의 주요 수거 대상은 더 이상 사용되지 않는 '상수'와 '클래스'입니다.6
상수 회수는 힙 객체와 유사하게, 더 이상 어떤 곳에서도 참조되지 않을 때 발생합니다. 반면, 클래스 언로딩(Unloading)은 매우 엄격한 조건을 만족해야만 가능하기에 흔하게 발생하지 않습니다 6:
해당 클래스의 모든 인스턴스가 힙에서 완전히 제거되어야 합니다.
해당 클래스를 로딩한 ClassLoader가 수거 대상이 되어야 합니다.
해당 클래스에 대한 java.lang.Class 객체가 어디에서도 참조되지 않아야 합니다(예: 리플렉션을 통해 사용되지 않아야 함).
이 세 가지 조건을 모두 만족해야만 클래스 메타데이터가 메서드 영역에서 제거될 수 있습니다. 이처럼 조건이 까다롭기 때문에 클래스 언로딩은 힙 회수에 비해 비용 대비 효과가 낮습니다.6

2. 가비지 컬렉션 핵심 알고리즘

쓰레기 대상을 식별했다면, 다음 단계는 이들을 효율적으로 메모리에서 제거하는 것입니다. 모든 현대적인 GC는 몇 가지 기본적인 알고리즘을 조합하고 변형하여 구현됩니다. 이 알고리즘들의 장단점을 이해하는 것은 JVM의 힙 구조가 왜 현재와 같은 모습으로 설계되었는지를 파악하는 데 매우 중요합니다.

2.1. 세대 가설: GC 설계의 근간

현대적인 GC 설계의 이론적 토대는 순수한 컴퓨터 과학 이론이 아니라, 실제 애플리케이션의 객체 생명주기를 관찰한 경험적 통계에 기반합니다. 이를 **세대 가설(Generational Hypothesis)**이라고 부릅니다.6
약한 세대 가설(Weak Generational Hypothesis): 대부분의 객체는 생성된 지 얼마 되지 않아 쓰레기가 된다. 즉, '단명'하는 객체가 대다수이다.6
강한 세대 가설(Strong Generational Hypothesis): 여러 번의 GC에서 살아남은 객체는 앞으로도 계속 살아남을 가능성이 높다. 즉, '장수'하는 객체는 계속 장수한다.6
세대 간 참조 가설(Inter-Generational Reference Hypothesis): 오래된 세대의 객체가 젊은 세대의 객체를 참조하는 경우는 매우 드물다.6
이러한 가설들은 중요한 설계적 결론으로 이어집니다. 모든 객체를 동일하게 취급하는 대신, 객체의 '나이'(GC에서 살아남은 횟수)에 따라 물리적으로 다른 메모리 공간에 배치하여 관리하는 것이 효율적이라는 것입니다. 이 아이디어는 JVM 힙을 **Young Generation(젊은 세대)**과 **Old Generation(늙은 세대)**으로 분리하는 구조를 탄생시켰습니다.3
Young Generation: 새로 생성된 객체들이 할당되는 공간입니다. 약한 세대 가설에 따라 대부분의 객체가 여기서 쓰레기가 되므로, 작고 빈번한 Minor GC가 발생합니다.13
Old Generation: Young Generation에서 여러 번의 Minor GC를 거치고도 살아남은 '장수' 객체들이 이동(Promotion)되는 공간입니다. 이곳의 객체들은 오랫동안 살아남을 확률이 높으므로, 크고 드물게 발생하는 Major GC 또는 Full GC의 대상이 됩니다.7
이러한 세대 구분 구조는 GC가 전체 힙을 매번 스캔하는 비효율을 피하고, 쓰레기가 많이 발생할 것으로 예상되는 Young Generation에 집중하여 빠르고 효율적으로 메모리를 회수할 수 있게 해줍니다. 한편, 드물게 발생하는 Old Generation에서 Young Generation으로의 참조는 '카드 테이블(Card Table)' 또는 '기억 집합(Remembered Set)'이라는 자료 구조를 통해 별도로 기록하여, Minor GC 시 전체 Old Generation을 스캔하지 않고도 참조 관계를 파악할 수 있도록 돕습니다.6

2.2. Mark-Sweep 알고리즘

가장 기본적인 추적(Tracing) GC 알고리즘으로, 이름처럼 두 단계로 동작합니다 3:
Mark(표시) 단계: GC Roots에서부터 시작하여 도달 가능한 모든 객체를 찾아 '살아있음'을 표시합니다.
Sweep(쓸기) 단계: 힙 전체를 스캔하면서 표시되지 않은 모든 객체(쓰레기)가 차지하던 메모리를 해제합니다.
이 알고리즘의 가장 큰 단점은 **메모리 파편화(Memory Fragmentation)**입니다.3 Sweep 단계 이후 힙에는 회수된 메모리 공간이 여기저기 흩어져 있는 '구멍' 형태로 남게 됩니다. 이로 인해 사용 가능한 총 메모리 공간은 충분하더라도, 연속된 큰 메모리 공간이 없어 큰 객체를 할당하지 못하는 상황이 발생할 수 있습니다. 또한, 힙에 살아있는 객체가 많을수록 Mark와 Sweep 단계 모두에서 거의 전체 힙을 순회해야 하므로 효율성이 떨어집니다.6

2.3. Mark-Copy 알고리즘

Mark-Sweep의 파편화 문제를 해결하기 위해 고안된 알고리즘입니다. 이 방식은 가용 메모리 영역을 동일한 크기의 두 공간, 예를 들어 'From' 공간과 'To' 공간으로 나눕니다. 객체 할당은 From 공간에서만 이루어집니다. GC가 발생하면 다음과 같이 동작합니다 6:
From 공간에 있는 살아있는 모든 객체를 식별합니다.
이 살아있는 객체들을 To 공간으로 순서대로 복사(Copy)하여 연속된 메모리 공간에 배치합니다.
From 공간에 남아있는 모든 객체는 쓰레기이므로, From 공간 전체를 한 번에 깨끗하게 비웁니다.
다음 GC 사이클에서는 두 공간의 역할이 바뀌어, To 공간이 새로운 From 공간이 됩니다.
이 알고리즘은 약한 세대 가설이 적용되는 Young Generation에 매우 적합합니다. 대부분의 객체가 쓰레기이므로 소수의 생존 객체만 복사하면 되기 때문에 매우 빠릅니다.18 HotSpot VM은 이를 Eden 영역 1개와 Survivor 영역 2개(S0, S1)로 구현하여, Eden과 S0에 있던 생존 객체를 S1으로 복사하는 방식으로 동작합니다.14 하지만 이 알고리즘은 항상 전체 공간의 절반을 비워둬야 하므로 메모리 낭비가 심하다는 단점이 있습니다. HotSpot VM은 Eden과 Survivor의 비율을 8:1:1 등으로 조절하여 이 낭비를 약 10% 수준으로 최소화합니다.6

2.4. Mark-Compact 알고리즘

Mark-Copy 알고리즘은 생존율이 높은 Old Generation에는 비효율적입니다. 대부분의 객체를 복사해야 하므로 비용이 크기 때문입니다. 이 문제를 해결하기 위해 Mark-Compact 알고리즘이 사용됩니다. 이 알고리즘은 Mark-Sweep과 유사하지만 추가적인 단계를 가집니다 4:
Mark(표시) 단계: Mark-Sweep과 동일하게 살아있는 객체를 모두 표시합니다.
Compact(압축) 단계: 모든 살아있는 객체들을 메모리 영역의 한쪽 끝으로 차례대로 이동시켜(slide) 연속된 공간에 배치합니다. 이 과정에서 이동된 객체를 참조하던 모든 변수의 주소 값도 함께 갱신해야 합니다.
마지막으로, 살아있는 객체들 뒤에 남은 공간 전체를 한 번에 해제합니다.
이 방식은 파편화를 해결하면서도 Mark-Copy처럼 메모리를 낭비하지 않아 Old Generation에 적합합니다.3 하지만 가장 큰 단점은 압축 단계의 비용이 매우 높다는 것입니다. 수많은 객체를 이동시키고 그에 대한 모든 참조를 수정하는 작업은 애플리케이션을 완전히 멈추는 Stop-The-World(STW) 시간을 길게 만듭니다.6
결론적으로, JVM의 세대별 힙 구조는 각 알고리즘의 장단점을 최적으로 활용하기 위한 공학적 타협의 산물입니다. 생존율이 낮은 Young Generation에서는 빠른 Mark-Copy를, 생존율이 높은 Old Generation에서는 공간 효율적인 Mark-Compact(또는 파편화를 감수하는 Mark-Sweep)를 사용하여 전체 GC 효율을 극대화하는 것입니다.

알고리즘
주요 목표
장점
단점
HotSpot VM에서의 주 사용처
Mark-Sweep
단순성, 메모리 회수
구현이 간단하고 객체 이동 오버헤드가 없음
심각한 메모리 파편화 발생, 힙이 찰수록 효율 저하
CMS와 같은 구형 GC의 Old Generation 수집 방식 16
Mark-Copy
파편화 제거, 빠른 수집
생존율이 낮을 때 매우 빠름, 연속된 가용 메모리 확보
메모리 공간의 일부를 항상 낭비함
Young Generation 수집 (Minor GC) 6
Mark-Compact
파편화 제거 및 공간 효율
메모리 사용 효율이 높고 파편화가 없음
객체 이동 및 참조 업데이트로 인한 긴 'Stop-The-World'
Old Generation 수집 (Major GC/Full GC) 6


3. HotSpot VM의 알고리즘 구현 심층 탐구

이론적인 알고리즘을 실제 고성능 가상 머신에 구현하는 것은 또 다른 차원의 문제입니다. HotSpot VM은 효율적인 GC를 위해 가비지 컬렉터, 실행 엔진, JIT(Just-In-Time) 컴파일러가 긴밀하게 협력하는 정교한 시스템을 갖추고 있습니다.

3.1. "Stop-The-World"의 필연성: 루트 노드 열거

GC가 정확하게 동작하려면, 분석을 시작하는 시점의 메모리 상태가 일관성을 유지해야 합니다. 만약 애플리케이션 스레드가 계속 실행되면서 객체 간의 참조 관계를 바꾸는 와중에 GC가 객체 그래프를 순회한다면, 살아있는 객체를 쓰레기로 오인하거나(데이터 유실) 쓰레기를 살아있는 객체로 착각하는(메모리 누수) 심각한 문제가 발생할 수 있습니다.6
이러한 '일관성 있는 스냅샷'을 확보하기 위해, GC는 루트 노드 열거(GC Roots에서부터 참조를 따라가는 초기 작업)를 시작하기 전에 반드시 모든 애플리케이션 스레드를 일시적으로 중지시켜야 합니다. 이것이 바로 **Stop-The-World(STW)**의 본질입니다. CMS, G1, ZGC와 같은 최첨단 동시(Concurrent) 컬렉터조차도 이 초기 루트 열거 단계에서의 짧은 STW는 피할 수 없습니다.2 현대 GC의 목표는 STW를 완전히 없애는 것이 아니라, 그 시간을 밀리초(ms) 단위, 혹은 그 이하로 줄이는 것입니다.

3.2. 안전 지점과 안전 영역 (Safe Points and Safe Regions)

애플리케이션 스레드를 아무 명령어에서나 임의로 멈추는 것은 매우 복잡하고 위험합니다. 스레드가 JVM 내부 자료 구조를 업데이트하는 중간에 멈출 경우 시스템 전체가 불안정한 상태에 빠질 수 있습니다. 또한, 모든 명령어 위치에서 GC가 가능하도록 관련 메타데이터(어떤 변수가 참조인지 등)를 생성하는 것은 엄청난 오버헤드를 유발합니다.
HotSpot VM은 이 문제에 대한 해법으로 **안전 지점(Safe Point)**이라는 개념을 도입했습니다.6 안전 지점이란 코드 실행 중 스레드를 멈추더라도 JVM의 상태가 안정적이고 예측 가능하도록 보장된 특정 위치를 말합니다. JIT 컴파일러는 메서드 호출, 루프의 끝(back-edge), 예외 발생 지점 등 실행이 길어질 가능성이 있는 곳에 안전 지점을 삽입합니다.21 GC는 스레드가 이 안전 지점에 도달했을 때만 스레드를 중지시킬 수 있습니다. **안전 영역(Safe Region)**은 한 걸음 더 나아가, JNI 코드 실행과 같이 특정 코드 블록을 실행하는 동안에는 객체 참조 관계가 절대 변하지 않음을 보장하는 영역을 의미합니다. 스레드가 안전 영역 안에 있을 경우, GC는 해당 스레드를 멈출 필요 없이 작업을 진행할 수 있습니다.

3.3. 스레드 중단 메커니즘: 자발적 중단

그렇다면 JVM은 어떻게 모든 스레드를 가장 가까운 안전 지점으로 유도하여 멈추게 할까요? 강제로 모든 스레드에 인터럽트를 거는 '선제적 중단(Preemptive Suspension)' 방식은 비효율적입니다. 대신 HotSpot VM은 훨씬 우아한 자발적 중단(Voluntary Suspension) 모델을 사용합니다.6
이 방식은 일종의 폴링(Polling) 메커니즘에 기반합니다. GC가 필요할 때 JVM은 특정 전역 플래그를 설정합니다. 모든 애플리케이션 스레드는 실행 중에 안전 지점을 지날 때마다 이 플래그를 확인하는 코드를 실행합니다. 만약 플래그가 설정된 것을 발견하면, 스레드는 스스로 실행을 멈추고 대기 상태에 들어갑니다.21
이 폴링 작업은 매우 빈번하게 일어나므로 극도로 효율적이어야 합니다. HotSpot VM은 특정 메모리 페이지에 대한 접근을 이용하는 영리한 하드웨어 트랩을 사용합니다. 평소에는 이 페이지를 읽는 test 어셈블리 명령어가 아무 비용 없이 통과하지만, GC가 STW를 유발해야 할 때 JVM은 해당 메모리 페이지에 대한 접근 권한을 막아버립니다. 그러면 test 명령어를 실행하는 스레드는 메모리 보호 폴트(fault)를 발생시키고, 미리 등록된 운영체제의 예외 핸들러가 이를 감지하여 해당 스레드를 안전하게 중단시킵니다. 이 덕분에 평상시의 폴링 오버헤드는 거의 0에 가깝습니다.21

3.4. OopMaps: 참조 위치의 빠른 식별

스레드가 안전 지점에서 멈췄다고 해도, GC는 해당 스레드의 스택과 CPU 레지스터의 수많은 데이터 중에서 어떤 것이 힙 객체를 가리키는 참조(HotSpot에서는 'oop' - ordinary object pointer라고 부름)이고 어떤 것이 단순한 정수 값인지 즉시 알아내야 합니다.
이 문제를 해결하기 위해 JIT 컴파일러는 코드를 네이티브 코드로 컴파일할 때 각 안전 지점마다 OopMap이라는 특별한 메타데이터를 함께 생성합니다.21 OopMap은 해당 안전 지점에서 스택의 어떤 슬롯과 어떤 레지스터가 객체 참조를 담고 있는지를 정확하게 알려주는 일종의 비트맵 지도입니다.
스레드가 안전 지점에서 멈추면, GC는 해당 위치의 OopMap을 참조하여 단번에 모든 로컬 GC Roots를 식별할 수 있습니다. 스택 전체를 보수적으로 스캔하며 참조인지 아닌지 추측할 필요가 없어지는 것입니다. 이 OopMap 덕분에 STW의 핵심 작업인 루트 노드 열거가 극적으로 빨라지며, 이는 전체 GC 성능 향상에 결정적인 기여를 합니다. 이처럼 효율적인 GC는 가비지 컬렉터, 실행 엔진, JIT 컴파일러 간의 깊은 수준의 협력 없이는 불가능하며, STW는 단순한 '일시 정지'가 아니라 이들 구성 요소가 정교하게 조율하는 복잡한 과정의 결과물입니다.

결론

지금까지 『JVM 밑바닥까지 파헤치기』 3.1절부터 3.4절의 내용을 바탕으로 JVM의 가비지 컬렉션 메커니즘을 심층적으로 살펴보았습니다. 분석을 통해 다음과 같은 핵심적인 결론을 도출할 수 있습니다.
첫째, '쓰레기'를 판별하는 기준인 도달 가능성 분석과 다양한 강도의 참조 타입은 객체의 생명주기를 정교하게 관리하기 위한 JVM의 핵심 철학을 보여줍니다. 이를 통해 개발자는 캐시나 특수 자원 관리와 같은 고급 메모리 관리 패턴을 구현할 수 있습니다.
둘째, JVM 힙의 **세대별 구조(Young/Old Generation)**는 임의적인 설계가 아니라, Mark-Sweep, Mark-Copy, Mark-Compact라는 근본적인 GC 알고리즘들의 장단점을 현실 세계의 객체 생존 패턴(세대 가설)에 맞춰 최적으로 조합한 공학적 해법의 결과물입니다. 각 세대에서 서로 다른 알고리즘을 적용함으로써 JVM은 전체적인 GC 효율을 극대화합니다.
셋째, 고성능 GC의 구현은 단순히 알고리즘을 적용하는 것을 넘어, 안전 지점(Safe Points), 자발적 중단, OopMaps와 같이 JIT 컴파일러와 실행 엔진이 긴밀하게 협력하는 시스템 수준의 최적화를 통해 완성됩니다. 이는 GC가 JVM의 독립된 모듈이 아니라, 코드 생성부터 스레드 실행에 이르기까지 모든 과정에 깊숙이 관여하는 통합 시스템임을 명확히 보여줍니다.
결론적으로, 가비지 컬렉션은 자바 개발자가 직접 마주할 일은 적지만, 애플리케이션의 성능과 안정성에 지대한 영향을 미치는 근본적인 기술입니다. 그 내부 동작 원리를 이해하는 것은 단순히 지적 호기심을 충족시키는 것을 넘어, GC 튜닝을 통해 시스템의 한계를 극복하고 더 견고하고 효율적인 애플리케이션을 구축하기 위한 필수적인 역량이라 할 수 있습니다.
