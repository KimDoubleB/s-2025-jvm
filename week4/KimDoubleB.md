**목차**
- 사례
    - 대용량 메모리 기기 대상 배포 전략
    - 클러스터 간 동기화로 인한 메모리 오버플로
    - 힙 메모리 부족으로 인한 오버플로 오류
    - 시스템을 느려지게 하는 외부 명령어
    - 서버 가상 머신 프로세스 비정상 종료
    - 부적절한 데이터 구조로 인한 메모리 과소비
    - 윈도우 가상 메모리로 인한 긴 일시 정지
    - 안전 지점으로 인한 긴 일시 정지
- 이클립스 구동시간 줄이기

<br/>

### 대용량 메모리 기기 대상 배포 전략

대용량 메모리 기기의 배포 방식 2가지
- (1) 인스턴스 하나가 거대한 자바 힙 메모리를 관리한다.
- (2) 여러 개의 인스턴스를 띄워 논리적인 클러스터를 구성한다.

<br/>

예제
- 서버 실행 효율이 안좋고, 웹 사이트가 장시간 응답하지 않는 일 발생
- 스펙
    - 16GB Memory, 64 Bit CentOS
    - Parallel Collector (Parallel scavanger + Parallel Old)
    - 1번의 배포 방식
- 문제
    - Parallel Collector는 일시 정지 시간보다는 처리량에 목적을 둠.
        - ⇒ 그렇기에 전체 GC 빈도는 가능한 낮게, 적어도 사용자가 이용중인 도중에 일어나지 않게 새벽에 수행하는 등 스케줄링 필요.
    - 웹 페이지 직렬화 하며 거대객체 쌓임. 곧장 구세대로 만들어지면서 금세 가득 참.
        - ⇒ 전체 GC 빈도를 제어하려면 구세대가 안정되어야 함. 장수하는 거대 객체 대량으로 만들어지는 일이 없어야 함.
        - ⇒ 브라우저-서버 애플리케이션에서 대다수 객체는 요청, 페이지 범위를 넘어 생존해서는 안됨. 세션/전역 수준으로 오래 살아남는 객체는 매우 적어야 함.
        - Q. 근데 거대 객체 자체는 장수 생존여부와 별개로 거대하기에 바로 구세대 만들어져서 위 해결방안으로는 커버가 불가능하지 않나?
            - 단명하게 끔 구성되면 문제는 없다. 요청 범위 내에서 소멸하는 경우, 다음 Full GC 때 회수되어 공간확보되므로 문제 없음.
            - 여기서 말하는건 계속 살아남아서 구세대에 남는 것을 의미.

<br/>

첫 번째 배포 방식과 현재 예시의 문제, 고려 해봐야 하는 점
- 힙 메모리 거대 블록 수거 → 일시정지 발생
    - 이 문제는 G1 컬렉터의 등장과 점진적 회복이 활발히 활용되며 많이 줄어들었음
- 64비트를 이용하며 대용량 메모리/힙을 사용할 수 있게 되었음
    - 하지만 압축 포인터 오버헤드, 프로세서 캐시라인 용량 요인 등 32비트보다 조금씩 느림
- 애플리케이션이 충분히 안정적이여야 함
    - 메모리에 문제가 있어도 힙 덤프 스냅숏 생성하기가 매우 힘듦. 스냅숏 파일 용량이 너무 크기 때문.

<br/>

이러한 문제로 두 번째 배포 방식을 이용하는 경우도 있음. 하지만 당연히 모든 것이 좋은 것은 아님
- 노드들이 전역 자원을 놓고 경합. 대표적으론 디스크. I/O 예외 일어나기 쉬움.
- Connection 같은 자원 풀 효율적 활용 어려움. 특정 인스턴스만 꽉차는 경우가 발생함.
- 로컬 캐시 이용이 활발한 경우, 인스턴스 당 로컬 캐시를 만드므로 메모리 낭비가 있음.

<br/>

해결 방법
- 32비트 인스턴스 5개로 클러스터 구성
- 메모리를 프로세스 당 2GB 씩 할당. 앞 단에 LB 구성
- CMS Collector로 변경

<br/>

### 힙 메모리 부족으로 인한 오버플로 오류

Memory Overflow 가끔 발생
- Window 32비트 시스템 → 프로세스 당 2GB 메모리 제약, Heap 1.6 GB 할당.
- 여유 메모리 없어서 오버플로 발생해도 덤프 파일 생성 불가
- `jstat` 이용해 확인해보니, GC 자주 안 일어나고 있고, 모든 메모리 구역 안정적.

<br/>

시스템 로그에 남은 것
- `OutOfMemoryError ... Unsafe.allocateMemory (Native Method) …`
- 2 GB 메모리 제약이 1.6 GB Heap에 할당한 상황
- Direct Memory는 Heap에 속하지 않음. 최대 0.4 GB만 사용 가능.

<br/>

Direct Memory의 경우, 공간이 부족하더라도 Garbage Collector에 능동적으로 알리지 못함
- Heap의 구세대가 꽉 차서 Full GC가 수행되기만을 기다림
- 수동으로 `System.gc()` 를 호출하는 방법도 있지만, 무조건 호출된다는 보장이 없음

<br/>

물리 메모리 용량이 적은 시스템이나, 32비트 애플리케이션에서는 자바 힙과 메서드 영역 외에 다음 영역들도 가용 메모리에서 상당한 비중을 차지하므로, 한계를 뛰어넘는 경우가 있음
- 다이렉트 메모리: `-XX:MaxDirectMemorySize` 를 통해 크기 조절. 부족하면 OOM 발생.
- 스레드 스택: `-Xss` 를 통해 조절. 깊이 넘는 요구오면 StackOverFlow 발생. 동적 확장 시도 시, 메모리 부족하면 OOM 발생.
- 소켓 버퍼 영역: 소켓 연결이 많은 상황에서 메모리가 부족해지면 IOException: Too many open files 발생
- 메타스페이스: 책에는 안나오지만 똑같지 뭐… `MaxMetaspaceSize` 를 통해 크기 조절.
- JNI 코드, Garbage collector 필요 메모리 등등…

<br/>

### 부적절한 데이터 구조로 인한 메모리 과소비

- HashMap<Long, Long> 100만개 생성
    - Eden 영역 빠르게 꽉참. GC 발생.
    - ParNew Collector → Mark-sweep을 이용하므로 살아남은 객체가 적어야 빠름
- HashMap<Long, Long>의 비효율성을 고려해서 코드 수정을 하는 편이 제일 좋음
    - long 2개를 저장하기 위한 값으로 총 88바이트가 필요함
        - Long(24 byte) x 2 + Map Entry (32 byte) + HashMap 참조 (8 byte)
        - long primitive type은 8 byte이므로, 16 byte 저장으로 끝낼 수 있는데 88 byte를 이용하는 것
        - 효율: 18% (16/88)

<br/>

이런거 고려하면 Primitive Collection 이용하는 편이 좋을 듯

https://github.com/vigna/fastutil/
- `Long2LongOpenHashMap` 등

<br/>

### 안전 지점으로 인한 긴 일시 정지

Hbase 클러스터 이용 중
- 일정 기간 운영하다보니 GC 일시정지 시간이 3초 이상 길어지는 일이 자주 생김

<br/>

접근 방식
- `-XX:+PrintSafepointStatistics`, `-XX:PrintSfaepointStatisticsCount=1` 옵션을 추가해 안전 지점에서의 통계 로그 출력
    - 일부 스레드가 안전 지점에 도착한 후 나머지 스레드가 도착할 때까지 대기하는 것을 발견
- 느린 스레드의 정체를 확인하기 위해 `-XX+SafepointTimeout`, `-XX:SafepointTimeoutDelay=2000` 옵션을 추가. 타임아웃을 발생시켜 문제의 스레드를 출력하게 함.
- 문제의 스레드 확인

<br/>

안전 지점 → “프로그램을 장시간 실행하는 특성이 있는가?”라는 원칙
- 메서드 호출, 순환문 점프, 비정상적인 점프 등
- **카운티드 루프(counted loop)**: int 등 범위가 좁은 데이터 타입을 루프 변수로 이용하는 순환문은 기본적으로 안전 지점 설정되지 않음
    - 순환문 하나 당 실행시간이 어떤지는 신경 안쓰고, 횟수에만 신경씀.
    - 한번 순회 시간이 엄청 길다면 카운티드 루프일지라도 오래 걸릴 수 밖에 없음.

<br/>

해결 방법
- `-XX:+UseCountedLoopSafepoints` 옵션을 이용해 활성화 (JDK 8에서는 비정상 종료시키는 버그 있음)
- Loop 횟수 변수를 long 등 범위가 큰 변수 타입으로 변경

<br/>

<br/>

----

> JVM Bytecode 검증 비활성화

최근 Java (JDK 13 이후)에서는 `-Xverify:none`과 `-noverify` 옵션이 deprecated
- 바이트코드 컴증은 필수 요소 (보안, 안정성 관점 등)

<br/>

바이트코드 검증?
- JVM이 클래스 파일 로드할 때, 바이트코드의 안전성, 무결성 검사하는 프로세스
- 클래스로더가 클래스를 메모리 올리기 전에 검증한다.
- 검증 항목
    - 타입 안정성 (변수/메서드 타입 올바른지)
    - 스택 일관성 (오버플로우/언더플로우 스택)
    - 접근 제어 (access modifier 규칙 준수)
    - 메모리 안정성 (배열 경계 벗어나는 접근 없는지)
    - 제어 흐름 (메서드 적절한 값 반환하는지, 점프가 유효한 위치로만 가는지)
- 즉, 악의적으로 수정된 `.class` 파일이 있는지, JVM Crash가 발생할 포인트가 있는지 검증하는 과정이라고 이해

<br/>

바이트 검증 비활성화 - Intellij IDEA에 추가해도 될까?
- plugins가 많다. 바이트코드 품질 보장될까?
- 보안적으로 괜히 모험을 떠나고 싶지 않다.
- 현대 JVM에서는 deprecated 된 만큼, 안정적이지 않다. 효과도 그리 크지 않을 것 같음

<br/>

최적화하고 싶다면 AppCDS 같이 클래스를 아카이빙 해두고 바로 사용하는 방식을 이용
- 아카이빙 중에 검증을 미리 수행하기 때문에 런타임에 검증을 안해서 더 효율적으로 수행이 가능함

<br/>

---

> 32비트와 64비트 → JVM 관점에서 살펴보기


주소 공간의 차이
- 32비트 → 2^32 → 4 기가바이트: **최대 메모리 공간이 4GB 사용 가능하다**
- 64비트 → 2^64 → 16 엑사바이트: 최대 메모리 공간이 16EB 사용 가능하다

<br/>

실제 힙 메모리 제약
- 32비트: 약 1.5~2 GB
    - OS 커널, JVM 자체, 네이티브 메모리 등이 주소 공간을 차지
- 64비트: X
    - 물리적 RAM 혹은 OS 제약에 의해서만 제한

| 항목 | 32비트 | 64비트 (압축) | 64비트 (비압축) |
| --- | --- | --- | --- |
| **포인터 크기** | 4B | 4B | 8B |
| **객체 헤더** | 8B | 12B | 16B |
| **최대 힙** | ~2GB | ~32GB | 수백GB |
| **캐시 효율** | 높음 | 높음 | 낮음 |
| **메모리 오버헤드** | 낮음 | 낮음 | 높음 (30-50%) |
| **캐시 라인 활용** | 최적 | 최적 | 비효율 |
| **NUMA 영향** | 낮음 | 중간 | 높음 |
| **인코딩/디코딩 비용** | 없음 | 매우 낮음 | 없음 |

<br/>

64비트에선 **압축 포인터(Compressed OOPs)**가 핵심
- Java 6 Update 23 이후 도입된 최적화 기법으로, 64비트 JVM에서 **32비트 포인터 사용 기법**
    - 활성화 조건 - **힙 크기가 32 GB보다 작을 경우**
        - 32 GB를 넘으면 32비트 포인터로 표현을 못함
        - 2^32 == 약 43억 개의 값
- 사용 시
    - 포인터: 8바이트 → 4바이트
    - 메모리 오버헤드: 64비트의 이점 + 32비트의 효율성
- 어떻게?
    - 64비트 → 모든 객체는 8 바이트(64 비트) 경계에 정렬
    - 8의 배수 주소의 이진수 들의 하위 3 비트는 항상 000 → 이 3비트는 저장할 필요가 없음.

<br/>

**효율화 (압축, 캐시 등)로 인해 32 GB 언저리의 힙 메모리 크기를 잡는 경우, 32 GB보다 작게 잡아 압축 포인터를 사용하는 것이 훨씬 좋음**

<br/>

----

> Intellij IDEA

<br/>


IntelliJ IDEA Version 변경하기
- 2025.2.4 최신버전 사용 중
- 기본적으로 `21.0.8 jcef` 사용
    - https://github.com/JetBrains/JetBrainsRuntime
    - https://github.com/JetBrains/JetBrainsRuntime/releases/tag/jbr-release-21.0.8b1038.73

<br/>

Intellij IDEA - Diagnostic tools
- VM option 변경 가능 (Xmx, …)
    - ZGC 도입해보기 (`-XX:+UseZGC`)
- Thread dump
- Capture Memory Snapshot (heapdump)
- Async Profiler 등 지원